#!/usr/bin/env node

/**
 * Module dependencies.
 */

var app = require('../app');
var debug = require('debug')('chat-and-meat:server');
var http = require('http');
var https = require('https');
var datasetup = require('../database/dataSetup');
var AESCrypt = require('../database/AESCrypt');
require('date-utils');
var moment = require('moment');
var verifier = require('gamecenter-identity-verifier');
const iap = require('in-app-purchase');

iap.config({
  applePassword:"",
  googlePublicKeyStrLive:
  ''
});

iap.setup(function (err) {
  if (err) {
      return console.error('something went wrong...');
  }
  else {
      console.log('iap init done');
  }
});
/**
* Get port from environment and store in Express.
*/
var userList = {};
var waitingList = {};
var roomList = {};
var channelList = {};
var diceList = {};
var blinddateList = {};
var footholdList = {waitLoc:[-270, -135, 0, 135, 270]};
var fishingList = {
  seatLoc:[
    {x:-247, y:140}, {x:-124, y:140}, {x:0, y:140}, {x:124, y:140}, {x:247, y:140},
    {x:-247, y:-230}, {x:-124, y:-230}, {x:0, y:-230}, {x:124, y:-230}, {x:247, y:-230}
  ]
};
var slotList = {};
var pianoList = {
  pianoLoc:{
    white:{width: 49, min_x: -313, x_length: 14, min_y: -100, max_y: 110},
    black:{width: 26, x:[-288, -240, -144, -96, -48, 48, 96, 192, 240, 288], min_y: -8, max_y: 110},
    y:[-226, 127]
  }
};
var hangmanList = {waitLoc:[-254, -131, -2, 129, 254]};
var runningList = {};
var squareLocList = [
  //home
  {x: -805, y: 610},
  //slot
  {x: -65, y: 710}
];

var port = normalizePort(process.env.PORT || '7000');
app.set('port', port);

// try {
// datasetup.connect(function(err_connect) {
//   if(err_connect)
//     console.log('error database connect/'+err_connect)
// });
// } catch (error) {
// console.log('error database throws/'+error);
// }

datasetup.init(datasetup);

/**
* Create HTTP server.
*/

var server = http.createServer(app);
server.on('error', function(error){
  console.log("server_error: "+error);
  var rec = {'reason': 'server_error'};
  datasetup.securityRecord(rec);

  const used = process.memoryUsage();
  for (let key in used) {
    console.log(`${key} ${Math.round(used[key] / 1024 / 1024 * 100) / 100} MB`);
  }
});
function pad(n, width, z) {
z = z || '0';
n = n + '';
return n.length >= width ? n : new Array(width - n.length + 1).join(z) + n;
}
function makePin() {
  var text = '';
  var possible = 'abcdefghijklmnopqrstuvwxyz0123456789';

  for ( var i=0; i < 32; i++ )
      {text += possible.charAt(Math.floor(Math.random() * possible.length));}

  return text;
}

/**
* Listen on provided port, on all network interfaces.
*/
var io = require('socket.io')();
io.listen(server, {
// default
//pingInterval: 5000,
//pingTimeout: 5000,
});
// console.log(io);
datasetup.io = io;
io.on('connection', function(socket) {
waitingList[socket.id] = socket.id;
// console.log(socket.id + ' connected');
socket.loginTimer = setTimeout(function(){
  socket.disconnect(true);
}, 60000);

socket.on('error', function(error){
  console.log("socket_error: "+error);
  var rec = {'reason': 'socket_error'};
  datasetup.securityRecord(rec);
  
  const used = process.memoryUsage();
  for (let key in used) {
    console.log(`${key} ${Math.round(used[key] / 1024 / 1024 * 100) / 100} MB`);
  }
});
// socket.on('connect_error', function(error){
//   console.log("connect_error: "+error);
//   const used = process.memoryUsage();
//   for (let key in used) {
//     console.log(`${key} ${Math.round(used[key] / 1024 / 1024 * 100) / 100} MB`);
//   }

// });

// socket.on('connect_timeout', function(error){
//   console.log("connect_timeout: "+error);
//   const used = process.memoryUsage();
//   for (let key in used) {
//     console.log(`${key} ${Math.round(used[key] / 1024 / 1024 * 100) / 100} MB`);
//   }
// });

socket.on('disconnect', function() {
  delete waitingList[socket.id];
  if(socket.name == undefined){
    console.log(socket.id + ' disconnected');
    return;
  }
  console.log(socket.name + ' disconnected');
  
  if (socket.room != undefined) {
    var toRoom = {nickname: socket.name, msg: 'leave'};
    var toChannel = {nickname: socket.name, result: 'leave'};
    if (socket.room.includes('@channel')) {
      if (channelList[socket.room] == undefined) {
        var rec = {'req': 'disconnect', 'reason': 'no channel', "nickname": socket.name};
        datasetup.securityRecord(rec);

        socket.emit('wrong', AESCrypt.socketEncrypt(rec));
        delete userList[socket.name];
        return;
      }

      var isCanceled = false;
      var index = channelList[socket.room].fashion.waitList.indexOf(socket.name);
      if (index >= 0) {
        if (channelList[socket.room].fashion.timer == undefined) {
          isCanceled = true;
          channelList[socket.room].fashion.waitList.splice(index, 1);
        }else{
          var timerArgs = channelList[socket.room].fashion.timer._timerArgs;
          let user = timerArgs[0];
          if (user.nickname == socket.name) {
            clearTimeout(channelList[socket.room].fashion.timer);
            fashionshow_end(timerArgs[0],timerArgs[1]);
          }else{
            isCanceled = true;
            channelList[socket.room].fashion.waitList.splice(index, 1);
          }
        }
      }

      if(isCanceled){
        var resData = {result: 'success', type: 'cancel', nickname: socket.name};
        io.to(socket.room).emit('fashionshow', AESCrypt.socketEncrypt(resData));
      }

      socket.leave(socket.room);

      delete channelList[socket.room].users[socket.name];
      if (Object.keys(channelList[socket.room].users).length == 0) {
        delete channelList[socket.room];
      }else{
        io.to(socket.room).emit('square', AESCrypt.socketEncrypt(toChannel));
      }
    } else if (socket.room == socket.name) {
      if(roomList[socket.room] == undefined){
        var rec = {'req': 'disconnect', 'reason': 'no visit room', "nickname": socket.name};
        datasetup.securityRecord(rec);

        socket.emit('wrong', AESCrypt.socketEncrypt(rec));
        delete userList[socket.name];
        return;
      }
      io.to(socket.room).emit('visit', AESCrypt.socketEncrypt(toRoom));
      
      delete roomList[socket.room][socket.name];
      var guests = Object.keys(roomList[socket.room]);
      for (var i=0; i<guests.length; i++) {
        if (userList[guests[i]] == undefined) {
          var rec = {'req': 'disconnect', 'reason': 'no guest user', "nickname": guests[i]};
          datasetup.securityRecord(rec);
          continue;
        }
        userList[guests[i]].leave(socket.room);
        delete userList[guests[i]].room;
      }
      delete roomList[socket.room];
    } else if (socket.room.includes('@dice')) {
      if(diceList[socket.room] == undefined){
        var rec = {'req': 'disconnect', 'reason': 'no dice room', "nickname": socket.name};
        datasetup.securityRecord(rec);

        socket.emit('wrong', AESCrypt.socketEncrypt(rec));
        delete userList[socket.name];
        return;
      }

      socket.leave(socket.room);

      delete diceList[socket.room].locList[socket.name];
      if (Object.keys(diceList[socket.room].locList).length == 0) {
        clearInterval(diceList[socket.room].timer);
        delete diceList[socket.room];
      }else{
        io.to(socket.room).emit('dice', AESCrypt.socketEncrypt(toChannel));
      }
    } else if(socket.room.includes('@blinddate')){
      if(blinddateList[socket.room] == undefined){
        var rec = {'req': 'disconnect', 'reason': 'no blinddate room', "nickname": socket.name};
        datasetup.securityRecord(rec);

        socket.emit('wrong', AESCrypt.socketEncrypt(rec));
        delete userList[socket.name];
        return;
      }

      io.to(socket.room).emit('blinddate', AESCrypt.socketEncrypt(toChannel));

      let roomId = socket.room;
      for(var i=0; i<blinddateList[roomId].userList.length; i++){
        let nickname = blinddateList[roomId].userList[i];
        if(userList[nickname] == undefined){
          var rec = {'req': 'disconnect', 'reason': 'no blinddate user', "nickname": nickname};
          datasetup.securityRecord(rec);
          continue;
        }

        userList[nickname].leave(roomId);
        delete userList[nickname].room;
      }
      delete blinddateList[roomId];
    } else if(socket.room.includes('@foothold')){
      if(footholdList[socket.room] == undefined){
        var rec = {'req': 'disconnect', 'reason': 'no foothold room', "nickname": socket.name};
        datasetup.securityRecord(rec);

        socket.emit('wrong', AESCrypt.socketEncrypt(rec));
        delete userList[socket.name];
        return;
      }

      socket.leave(socket.room);

      delete footholdList[socket.room].userList[socket.name];
      for(var i=0; i<footholdList[socket.room].indexList.length; i++){
        if(footholdList[socket.room].indexList[i] == socket.name){
          delete footholdList[socket.room].indexList[i];
          break;
        }
      }
      if (Object.keys(footholdList[socket.room].userList).length == 0) {
        clearTimeout(footholdList[socket.room].timer);
        delete footholdList[socket.room];
      }else{
        io.to(socket.room).emit('foothold', AESCrypt.socketEncrypt(toChannel));
      }
    } else if(socket.room.includes('@slot')){
      if(slotList[socket.room] == undefined){
        var rec = {'req': 'disconnect', 'reason': 'no slot room', "nickname": socket.name};
        datasetup.securityRecord(rec);
        socket.emit('wrong', AESCrypt.socketEncrypt(rec));
        delete userList[socket.name];
        return;
      }

      delete slotList[socket.room][socket.name];
      if(Object.keys(slotList[socket.room]).length == 0){
        delete slotList[socket.room];
      }else{
        io.to(socket.room).emit('slot', AESCrypt.socketEncrypt(toChannel));
      }
    } else if(socket.room.includes('@fishing')){
      if(fishingList[socket.room] == undefined){
        var rec = {'req': 'disconnect', 'reason': 'no fishing room', "nickname": socket.name};
        datasetup.securityRecord(rec);
        socket.emit('wrong', AESCrypt.socketEncrypt(rec));
        delete userList[socket.name];
        return;
      }else if(fishingList[socket.room][socket.name] == undefined){
        var rec = {'req': 'disconnect', 'reason': 'not in the fishing room', "nickname": socket.name};
        datasetup.securityRecord(rec);
        socket.emit('wrong', AESCrypt.socketEncrypt(rec));
        delete userList[socket.name];
        return;
      }
  
      clearTimeout(fishingList[socket.room][socket.name].timer);
      delete fishingList[socket.room][socket.name];
      if(Object.keys(fishingList[socket.room]).length == 0){
        delete fishingList[socket.room];
      }else{
        io.to(socket.room).emit('fishing', AESCrypt.socketEncrypt(toChannel));
      }

    } else if(socket.room.includes('@piano')){
      if(pianoList[socket.room] == undefined){
        var rec = {'req': 'disconnect', 'reason': 'no piano room', "nickname": socket.name};
        datasetup.securityRecord(rec);
        socket.emit('wrong', AESCrypt.socketEncrypt(rec));
        delete userList[socket.name];
        return;
      }

      delete pianoList[socket.room][socket.name];
      if(Object.keys(pianoList[socket.room]).length == 0){
        delete pianoList[socket.room];
      }else{
        io.to(socket.room).emit('piano', AESCrypt.socketEncrypt(toChannel));
      }
    } else if(socket.room.includes('@hangman')){
      if(hangmanList[socket.room] == undefined){
        var rec = {'req': 'disconnect', 'reason': 'no hangman room', "nickname": socket.name};
        datasetup.securityRecord(rec);

        socket.emit('wrong', AESCrypt.socketEncrypt(rec));
        delete userList[socket.name];
        return;
      }

      socket.leave(socket.room);

      if(hangmanList[socket.room].userList[socket.name].timer){
        clearTimeout(hangmanList[socket.room].userList[socket.name].timer);
        // delete hangmanList[socket.room].userList[socket.name].timer;
      }
      delete hangmanList[socket.room].userList[socket.name];
      for(var i=0; i<hangmanList[socket.room].indexList.length; i++){
        if(hangmanList[socket.room].indexList[i] == socket.name){
          delete hangmanList[socket.room].indexList[i];
          break;
        }
      }
      if (Object.keys(hangmanList[socket.room].userList).length == 0) {
        clearTimeout(hangmanList[socket.room].timer);
        delete hangmanList[socket.room].timer;
        delete hangmanList[socket.room];
      }else{
        io.to(socket.room).emit('hangman', AESCrypt.socketEncrypt(toChannel));
      }
    } else if(socket.room.includes('@running')){
      if(runningList[socket.room] == undefined){
        var rec = {'req': 'disconnect', 'reason': 'no running room', "nickname": socket.name};
        datasetup.securityRecord(rec);

        socket.emit('wrong', AESCrypt.socketEncrypt(rec));
        delete userList[socket.name];
        return;
      }

      socket.leave(socket.room);

      if(runningList[socket.room].userList[socket.name].timer){
        clearTimeout(runningList[socket.room].userList[socket.name].timer);
      }
      delete runningList[socket.room].userList[socket.name];
      if (Object.keys(runningList[socket.room].userList).length == 0) {
        if(runningList[socket.room].timer._turn == 'bet'){
          clearTimeout(runningList[socket.room].timer);
        }else if(runningList[socket.room].timer._turn == 'game'){
          clearImmediate(runningList[socket.room].timer);
        }
        
        delete runningList[socket.room];
      }else{
        io.to(socket.room).emit('running', AESCrypt.socketEncrypt(toChannel));
      }
    } else {
      var master = userList[socket.room];
      if (master == undefined) {
        var rec = {'req': 'disconnect', 'reason': 'no master user', "nickname": socket.name};
        datasetup.securityRecord(rec);

        socket.emit('wrong', AESCrypt.socketEncrypt(rec));
        delete userList[socket.name];
        return;
      }
      if (roomList[socket.room] == undefined) {
        var rec = {'req': 'disconnect', 'reason': 'no visit room', "nickname": socket.name};
        datasetup.securityRecord(rec);

        socket.emit('wrong', AESCrypt.socketEncrypt(rec));
        delete userList[socket.name];
        return;
      }

      delete roomList[socket.room][socket.name];
      if (Object.keys(roomList[socket.room]).length <= 1) {
        toRoom['isSolo'] = true;
        delete roomList[socket.room];
        delete master.room;
      }

      socket.leave(socket.room);
      io.to(socket.room).emit('visit', AESCrypt.socketEncrypt(toRoom));
    }
  }

  delete userList[socket.name];
});

socket.on('register', function(data) {
  try {
    var decData = AESCrypt.socketDecrypt(data);
  } catch (error) {
    console.log('error:'+error);
    var rec = {'req': 'register', 'reason': 'Invalid data', 'error': error};
    datasetup.securityRecord(rec);
    socket.emit('wrong', AESCrypt.socketEncrypt(rec));

    socket.disconnect();
    return;
  }

  console.log('register'+JSON.stringify(decData));

  if (socket.need_nick == undefined) {
    console.log('need nick error');
    var rec = {'req': 'register', 'reason': 'need nick error', 'data': decData};
    datasetup.securityRecord(rec);
    socket.emit('wrong', AESCrypt.socketEncrypt(rec));

    socket.disconnect();
    return;
  }

  if (decData.nickname == undefined) {
    console.log('nickname undefined error');
    var rec = {'req': 'register', 'reason': 'nickname undefined', 'data': decData};
    datasetup.securityRecord(rec);
    socket.emit('wrong', AESCrypt.socketEncrypt(rec));

    socket.disconnect();
    return;
  }

  var nick = decData.nickname.trim();
  if (nick.length < 1 || nick.length > 12) {
    console.log('nickname length error');
    var rec = {'req': 'register', 'reason': 'nickname length', 'data': decData};
    datasetup.securityRecord(rec);
    socket.emit('wrong', AESCrypt.socketEncrypt(rec));

    socket.disconnect();
    return;
  }

  if (nick.includes('@') || nick.includes('/') || nick.includes('\\') || nick.includes('"') || nick.includes(' ')) {
    console.log('Invalid nickname error');
    var rec = {'req': 'register', 'reason': 'Invalid nickname', 'data': decData};
    datasetup.securityRecord(rec);
    socket.emit('wrong', AESCrypt.socketEncrypt(rec));

    socket.disconnect();
    return;
  }

  if (decData.gender == undefined || decData.gender < 0 || decData.gender > 1) {
    console.log('gender data error');
    var rec = {'req': 'register', 'reason': 'Invalid gender data', 'data': decData};
    datasetup.securityRecord(rec);
    socket.emit('wrong', AESCrypt.socketEncrypt(rec));

    socket.disconnect();
    return;
  }

  datasetup.checkNickname(decData.nickname, function(err, data) {
    var resData = {};
    if (err) {
      resData['result'] = 'fail';
      resData['error'] = err;
      socket.emit('login', AESCrypt.socketEncrypt(resData));
    } else {
      if (data.length == 0) {
        datasetup.register(decData.nickname, decData.gender, socket.need_nick, function(err, data) {
          if (err) {
            resData['result'] = 'fail';
            resData['error'] = err;
          } else {
            data[0].cash = String(data[0].cash);
            resData['result'] = 'success';
            resData['userData'] = data[0];
            resData['furnitureData'] = [];
            resData['blockList'] = [];
            resData['adoptData'] = [];

            delete waitingList[socket.id];
            socket.name = decData.nickname;
            socket.chatlang = socket.need_nick[3];
            userList[decData.nickname] = socket;
            delete socket.need_nick;
          }
          socket.emit('login', AESCrypt.socketEncrypt(resData));
        });
      } else {
        decData['result'] = 'duple_nick';
        socket.emit('login', AESCrypt.socketEncrypt(decData));
      }
    }
  });
});
socket.on('login', function(data) {
  try {
    var decData = AESCrypt.socketDecrypt(data);
  } catch (error) {
    console.log('error:'+error);
    var rec = {'req': 'login', 'reason': 'Invalid data', 'error': error};
    datasetup.securityRecord(rec);

    socket.emit('wrong', AESCrypt.socketEncrypt(rec));
    socket.disconnect();
    return;
  }

  console.log('login '+JSON.stringify(decData));
  
  if (decData.language == undefined) {
    console.log('login language error');
    var rec = {'req': 'login', 'reason': 'login language error', 'data': decData};
    datasetup.securityRecord(rec);

    socket.emit('wrong', AESCrypt.socketEncrypt(rec));
    socket.disconnect();
    return;
  }

  if(decData.login_method == datasetup.protocol.login_method.android){
    // google id_token -> user_uid
    var option = {
      host: 'www.googleapis.com',
      //rejectUnauthorized : false,
      path: '/oauth2/v3/tokeninfo?id_token=' + decData.login_info
    }
    
    https.get(option, function(resp){
      resp.on('data', function(chunk){
        try {
          var gres = JSON.parse(chunk);
          // console.log(gres);
        } catch (error) {
          console.log('error:'+error);
          var rec = {'req': 'login', 'reason': 'parsing error', 'error': error};
          datasetup.securityRecord(rec);
      
          socket.emit('wrong', AESCrypt.socketEncrypt(rec));
          socket.disconnect();
          return;
        }
        if(gres.sub == undefined || gres.email == undefined){
          decData['result'] = 'google_login_error';
          decData['error'] = gres;
          socket.emit('login', AESCrypt.socketEncrypt(decData));
          socket.disconnect();
          return;
        }
        getLogin(gres.sub, gres.email);
      });
    }).on('error',(e) => {
      console.log('https_error:'+e);
      var rec = {'req': 'login', 'reason': 'https error', 'error': e};
      datasetup.securityRecord(rec);
  
      socket.emit('wrong', AESCrypt.socketEncrypt(rec));
      socket.disconnect();
      return;
    });

    // var gres = {
    //   azp: '453240778135-csk6b2ajpm7715ku9b439dku9h5c4udg.apps.googleusercontent.com',
    //   aud: '453240778135-aifvqmvqs4h1bpmvi9eb48eit39999bl.apps.googleusercontent.com',
    //   sub: decData.id_token,
    //   email: 'tina10321@gmail.com',
    //   email_verified: 'true',
    //   iss: 'https://accounts.google.com',
    //   iat: '1512612525',
    //   exp: '1512616125',
    //   name: 'seon oh',
    //   given_name: 'seon',
    //   family_name: 'oh',
    //   alg: 'RS256',
    //   kid: '477d17972d2a001074d586b588976d234296801e'};

  } else if(decData.login_method == datasetup.protocol.login_method.ios){
    if(decData.login_info == undefined){
      var rec = {'req': 'login', 'reason': 'login info undefined', 'data': decData};
      datasetup.securityRecord(rec);

      socket.emit('wrong', AESCrypt.socketEncrypt(rec));
      socket.disconnect();
      return;
    }
      var displayName = decData.login_info.displayName;
      delete decData.login_info.displayName;
      verifier.verify(decData.login_info, function (err, token) {
        if (err) {
          decData['result'] = 'fail';
          decData['error'] = err;
          socket.emit('login', AESCrypt.socketEncrypt(decData));
          socket.disconnect();
        }else{
          // use token in here. 
          getLogin(token.playerId,displayName);
        }
      });

  }else if(decData.login_method == datasetup.protocol.login_method.guest){
    if(decData.ID == undefined || decData.ID.trim().length < 1 ||decData.ID.length > 15
    || decData.ID.includes(" ") || decData.ID.includes("/")
    || decData.ID.includes("\\") || decData.ID.includes("\"")||decData.PW == undefined 
    || decData.PW.trim().length < 1 ||decData.PW.length > 20
    || decData.PW.includes(" ") || decData.PW.includes("/")
    || decData.PW.includes("\\") || decData.PW.includes("\"")){
      var rec = {'req':'login','reason':'Invalid guest login info','data':decData};
      datasetup.securityRecord(rec);

      socket.emit('wrong', AESCrypt.socketEncrypt(rec));
      socket.disconnect();
      return;
    }

    getLogin(decData.ID,decData.PW);
  }else{
    console.log('login method error');
    var rec = {'req':'login','reason':'login method error','data':decData};
    datasetup.securityRecord(rec);

    socket.emit('wrong', AESCrypt.socketEncrypt(rec));
    socket.disconnect();
    return;
  }

  function getLogin(uid, email){
    datasetup.getBlockDate(uid, function(err,data){
      var resData = {};
      if(err){
        resData['result'] = 'fail';
        resData['error'] = err;
        socket.emit('login', AESCrypt.socketEncrypt(resData));
        socket.disconnect();
      }else{
        if(data.length > 0){
          let blockDate =  Date.parse(data[0].block_date);
          if(blockDate != undefined && (blockDate - new Date()) > 0){
            resData['result'] = 'block';
            resData['block_date'] = blockDate //.toFormat('YYYY-MM-DD HH24:MI:SS');
            socket.emit('login', AESCrypt.socketEncrypt(resData));
            socket.disconnect();
            return;
          }
        }

        datasetup.updateRecentDate(decData.login_method, uid, decData.language, function(err, data) {
          if (err) {
            resData['result'] = 'fail';
            resData['error'] = err;
            socket.emit('login', AESCrypt.socketEncrypt(resData));
            socket.disconnect();
          } else {
            if (data.affectedRows == 1) {
              datasetup.getUserFromUid(decData.login_method, uid, function(err, data) {
                if (err) {
                  resData['result'] = 'fail';
                  resData['error'] = err;
                  socket.emit('login', AESCrypt.socketEncrypt(resData));
                  socket.disconnect();
                } else {
                  if(decData.login_method == datasetup.protocol.login_method.guest){
                    if(data[0].email != email){
                      resData['result'] = 'diff_pw';
                      socket.emit('login', AESCrypt.socketEncrypt(resData));
                      socket.disconnect();
                      return;
                    }
                  }

                  data[0].cash = String(data[0].cash);
                  var nickname = data[0]['nickname'];
                  if (userList.hasOwnProperty(nickname)) {
                    var otherRes = {'result': 'duple_login'};
                    var otherSocket = userList[nickname];
                    otherSocket.emit('login', AESCrypt.socketEncrypt(otherRes));
                    otherSocket.disconnect();
                  }

                  console.log('login '+ nickname+'/'+decData.login_method+'/'+decData.language);
                  resData['userData'] = data[0];
                  datasetup.getCurrentFurnitures(nickname, false, function(err, data) {
                    if (err) {
                      resData['result'] = 'fail';
                      resData['error'] = err;
                      socket.emit('login', AESCrypt.socketEncrypt(resData));
                      socket.disconnect();
                    } else {
                      resData['furnitureData'] = data;

                      datasetup.getAdopt(nickname, function(err, data){
                        if(err){
                          resData['result'] = 'fail';
                          resData['error'] = err;
                          socket.emit('login', AESCrypt.socketEncrypt(resData));
                          socket.disconnect();
                        }else{
                          for(var i=0; i<data.length; i++){
                            if(data[i].adoptData){
                              data[i].adoptData = JSON.parse(data[i].adoptData);
                            }
                          }
                          resData['adoptData'] = data;

                          datasetup.getBlockList(nickname, function(err, data) {
                            if (err) {
                              resData['result'] = 'fail';
                              resData['error'] = err;
                              socket.emit('login', AESCrypt.socketEncrypt(resData));
                              socket.disconnect();
                            } else {
                              resData['result'] = 'success';
                              resData['blockList'] = data;
    
                              delete waitingList[socket.id];
                              socket.name = nickname;
                              socket.chatlang = decData.language;
                              userList[nickname] = socket;
    
                              if(socket.loginTimer){
                                clearTimeout(socket.loginTimer);
                                delete socket.loginTimer;
                              }
                              socket.emit('login', AESCrypt.socketEncrypt(resData));
                            }
                          });
                        }
                      });
                    }
                  });
                }
              });
            } else {
              socket.need_nick = [decData.login_method, uid, email, decData.language];
              resData['result'] = 'need_nick';
              socket.emit('login', AESCrypt.socketEncrypt(resData));
            }
          }
        });
      }
    });
  }
});

socket.on('userList', function(){
  onUserList('userList');
});
socket.on('nickScoreList', function(){
  onUserList('nickScoreList');
});

function onUserList(to) {
  if (socket.name == undefined) {
    var rec = {'req': 'userList', 'reason': 'not_logined'};
    datasetup.securityRecord(rec);

    socket.emit('wrong', AESCrypt.socketEncrypt(rec));
    socket.disconnect();
    return;
  }

  var nicknames = Object.keys(userList);
  var index = nicknames.indexOf(socket.name);
  if (index < 0) {
    var rec = {'req': 'userList', 'reason': 'no user', "nickname": socket.name};
    datasetup.securityRecord(rec);

    socket.emit('wrong', AESCrypt.socketEncrypt(rec));
    socket.disconnect();
    return;
  }
  nicknames.splice(index, 1);
  var res = {};
  datasetup.getUsersFromNick(nicknames, function(err, data) {
    if (err) {
      res['result'] = 'fail';
      res['error'] = err;
    } else {
      res['result'] = 'success';
      res['userList'] = data;
    }
    socket.emit(to, AESCrypt.socketEncrypt(res));
  });
}

socket.on('searchUser', function(data){
  try {
  var decData = AESCrypt.socketDecrypt(data);
  } catch (error) {
    var rec = {'req': 'searchUser', 'reason': 'Invalid data', "nickname": socket.name};
    datasetup.securityRecord(rec);

    socket.emit('wrong', AESCrypt.socketEncrypt(rec));
    socket.disconnect();
    return;
  }

  if (socket.name == undefined) {
    var rec = {'req': 'searchUser', 'reason': 'not_logined', 'data': decData};
    datasetup.securityRecord(rec);

    socket.emit('wrong', AESCrypt.socketEncrypt(rec));
    socket.disconnect();
    return;
  }

  if(decData.query == undefined || decData.query.length > 12){
    var rec = {'req': 'searchUser', 'reason': 'Invalid query data', data: decData, nickname: socket.name};
    datasetup.securityRecord(rec);

    socket.emit('wrong', AESCrypt.socketEncrypt(rec));
    socket.disconnect();
    return;
  }

  datasetup.searchUsers(decData.query, function(err, data){
    if (err) {
      decData['result'] = 'fail';
      decData['error'] = err;
    } else {
      decData['result'] = 'success';
      decData['userList'] = data;
    }
    socket.emit('userList', AESCrypt.socketEncrypt(decData));
  });
});

socket.on('friendList', function() {
  if (socket.name == undefined) {
    var rec = {'req': 'friendList', 'reason': 'not_logined'};
    datasetup.securityRecord(rec);

    socket.emit('wrong', AESCrypt.socketEncrypt(rec));
    socket.disconnect();
    return;
  }
  datasetup.getFriendList(socket.name, function(err, data) {
    var resData = {};
    if (err) {
      resData['result'] = 'fail';
      resData['error'] = err;
    } else {
      resData['result'] = 'success';
      resData['friendList'] = data;
    }
    socket.emit('friendList', AESCrypt.socketEncrypt(resData));
  });
});

socket.on('profile', function(data) {
  try {
    var decData = AESCrypt.socketDecrypt(data);
  } catch (error) {
    var rec = {'req': 'profile', 'reason': 'Invalid data', "nickname": socket.name};
    datasetup.securityRecord(rec);

    socket.emit('wrong', AESCrypt.socketEncrypt(rec));
    socket.disconnect();
    return;
  }

  if (socket.name == undefined) {
    var rec = {'req': 'profile', 'reason': 'not_logined', 'data': decData};
    datasetup.securityRecord(rec);

    socket.emit('wrong', AESCrypt.socketEncrypt(rec));
    socket.disconnect();
    return;
  }

  if (decData.nickname == undefined) {
    var rec = {'req': 'profile', 'reason': 'Invalid nickname data', "nickname": socket.name, "data": decData};
    datasetup.securityRecord(rec);

    socket.emit('wrong', AESCrypt.socketEncrypt(rec));
    socket.disconnect();
    return;
  }

  var nick = decData.nickname.trim();
  if (nick.includes(' ') || nick.includes('@') || nick.includes('/') || nick.includes('\\') || nick.includes('"') || nick.length < 1 || nick.length > 12) {
    var rec = {'req': 'profile', 'reason': 'Invalid nickname data', 'nickname':socket.name};
    datasetup.securityRecord(rec);

    socket.emit('wrong', AESCrypt.socketEncrypt(rec));
    socket.disconnect();
    return;
  }

  datasetup.getUserFromNick(nick, function(err, data) {
    var resData = {};
    if (err) {
      resData['result'] = 'fail';
      resData['error'] = err;
      socket.emit('profile', AESCrypt.socketEncrypt(resData));
    } else {
      if (data.length == 0) {
        resData['nickname'] = nick;
        resData['result'] = 'no_user';
        socket.emit('profile', AESCrypt.socketEncrypt(resData));
      } else {
        resData['userData'] = data[0];

        datasetup.getHaveItemLength(nick, function(err, data){
          if(err){
            resData['result'] = 'fail';
            resData['error'] = err;
            socket.emit('profile', AESCrypt.socketEncrypt(resData));
          }else{
            resData['haveItemData'] = data;

            var itemData = datasetup.getItemLength();
            resData['itemData'] = itemData;

            datasetup.checkFriend(socket.name, nick, function(err, data) {
              if (err) {
                resData['result'] = 'fail';
                resData['error'] = err;
              } else {
                resData['result'] = 'success';
                if (data.length == 0) {
                  resData['isFriend'] = false;
                } else {
                  resData['isFriend'] = true;
                }
              }
              socket.emit('profile', AESCrypt.socketEncrypt(resData));
            });
          }
        });
      }
    }
  });
});

socket.on('chat', function(data) {
  try {
    var decData = AESCrypt.socketDecrypt(data);
  } catch (error) {
    console.log('error:'+error);
    var rec = {'req': 'chat', 'reason': 'Invalid data', 'error': error, 'nickname': socket.name};
    datasetup.securityRecord(rec);

    socket.emit('wrong', AESCrypt.socketEncrypt(rec));
    socket.disconnect();
    return;
  }

  if (socket.name == undefined) {
    var rec = {'req': 'chat', 'reason': 'not_logined', 'data': decData};
    datasetup.securityRecord(rec);

    socket.emit('wrong', AESCrypt.socketEncrypt(rec));
    socket.disconnect();
    return;
  }

  if(decData.msg.length > 200){
    var rec = {'req': 'chat', 'reason': 'too_long_msg', 'data': decData, 'nickname':socket.name};
    datasetup.securityRecord(rec);

    socket.emit('wrong', AESCrypt.socketEncrypt(rec));
    socket.disconnect();
    return;
  }
  
  decData['language'] = socket.chatlang;
  decData['from'] = socket.name;
  decData['sendTime'] = new Date().toFormat('YYYY-MM-DD HH24:MI:SS');
  console.log('chat '+JSON.stringify(decData));
  data = AESCrypt.socketEncrypt(decData);

  if (decData.to == undefined) {
    if (socket.room == undefined) {
      return;
    }

    io.to(socket.room).emit('chat', data);
  } else {
    var nick = decData.to.trim();
    if (nick.includes(' ') || nick.includes('@') || nick.includes('/') || nick.includes('\\') || nick.includes('"') || nick.length < 1 || nick.length > 12) {
      console.log('nickname error');
      var rec = {'req': 'chat', 'reason': 'Invalid nickname data', 'data': decData, 'nickname': socket.name};
      datasetup.securityRecord(rec);
      socket.emit('wrong', AESCrypt.socketEncrypt(rec));

      socket.disconnect();
      return;
    }

    if (decData.message_type == datasetup.protocol.message_type.chat) {
      if (userList[decData.to] == undefined) {
        decData.result = 'no_user';
        socket.emit('chat', AESCrypt.socketEncrypt(decData));
        return;
      }

      if (socket.name == decData.to) {
        socket.emit('chat', data);
      } else {
        socket.emit('chat', data);
        userList[decData.to].emit('chat', data);
      }
    } else if (decData.message_type == datasetup.protocol.message_type.friend) {
      var userSocket;
      if(userList[decData.to] != undefined){
        userSocket = userList[decData.to];
      }

      var encData;
      if (decData.msg == 'accept') {
        // if(socket.friendRequest != undefined){
        //   let index = socket.friendRequest.indexOf(decData.to);
        //   if(index < 0){
        //     var rec = {'req': 'chat', 'reason': 'Invalid friend accept data', 'data': decData, 'nickname': socket.name};
        //     datasetup.securityRecord(rec);
        //     socket.emit('wrong', AESCrypt.socketEncrypt(rec));

        //     socket.disconnect();
        //     return;
        //   }else{
        //     socket.friendRequest.splice(index, 1);
        //   }
        // }

        datasetup.getFriendList(socket.name, function(err, res) {
          if (err) {
            decData.msg = 'fail_to_accept';
            encData = AESCrypt.socketEncrypt(decData);
            socket.emit('chat', encData);
            if(userSocket){
              userSocket.emit('chat', encData);
            }
          } else {
            if (res.length < 100) {
              datasetup.getFriendList(decData.to, function(err, res){
                if(err){
                  decData.msg = 'fail_to_accept';
                  encData = AESCrypt.socketEncrypt(decData);
                  socket.emit('chat', encData);
                  if(userSocket){
                    userSocket.emit('chat', encData);
                  }
                }else{
                  if(res.length < 100){
                    datasetup.checkFriend(socket.name, decData.to, function(err, data) {
                      if (err) {
                        decData.msg = 'fail_to_accept';
                        encData = AESCrypt.socketEncrypt(decData);
                        socket.emit('chat', encData);
                        if(userSocket){
                          userSocket.emit('chat', encData);
                        }
                      } else {
                        if (data.length == 0) {
                          datasetup.addFriend(socket.name, decData.to, function(err, data) {
                            if (err) {
                              decData.msg = 'fail_to_accept';
                            } else {
                              decData.msg = 'accept';
                            }
                            encData = AESCrypt.socketEncrypt(decData);
                            socket.emit('chat', encData);
                            if(userSocket){
                              userSocket.emit('chat', encData);
                            }
                          });
                        } else {
                          decData.msg = 'duple_friend';
                          encData = AESCrypt.socketEncrypt(decData);
                          socket.emit('chat', encData);
                          if(userSocket){
                            userSocket.emit('chat', encData);
                          }
                        }
                      }
                    });
                  }else{
                    decData.msg = 'limit_of_friend_number';
                    encData = AESCrypt.socketEncrypt(decData);
                    socket.emit('chat', encData);
                    if(userSocket){
                      userSocket.emit('chat', encData);
                    }
                  }
                }
              });
            } else {
              decData.msg = 'limit_of_friend_number';
              encData = AESCrypt.socketEncrypt(decData);
              socket.emit('chat', encData);
              if(userSocket){
                userSocket.emit('chat', encData);
              }
            }
          }
        });
      } else if (decData.msg == 'request') {
        if(userSocket == undefined){
          decData.msg = 'no_user';
          socket.emit('chat', AESCrypt.socketEncrypt(decData));
        }else{
          datasetup.getFriendList(socket.name, function(err, res) {
            if (err) {
              decData.msg = 'fail_to_request';
              encData = AESCrypt.socketEncrypt(decData);
            } else {
              if (res.length < 100) {
                // if(userList[decData.to].friendRequest == undefined){
                //   userList[decData.to].friendRequest = [];
                // }else if(userList[decData.to].friendRequest.includes(socket.name)){
                //   decData.msg = 'request_duplcate';
                //   socket.emit('chat', AESCrypt.socketEncrypt(decData));
                //   return;
                // }
                // userList[decData.to].friendRequest.push(socket.name);

                encData = data;
                if(userSocket){
                  userSocket.emit('chat', encData);
                }
                
              } else {
                decData.msg = 'limit_of_friend_number';
                encData = AESCrypt.socketEncrypt(decData);
              }
            }
            socket.emit('chat', encData);
          });
        }          
      } else {
        if (decData.msg == 'refuse') {
          encData = data;

          // if(socket.friendRequest != undefined){
          //   let index = socket.friendRequest.indexOf(decData.to);
          //   if(index < 0){
          //     var rec = {'req': 'chat', 'reason': 'Invalid friend refuse data', 'data': decData, 'nickname': socket.name};
          //     datasetup.securityRecord(rec);
          //     socket.emit('wrong', AESCrypt.socketEncrypt(rec));

          //     socket.disconnect();
          //     return;
          //   }else{
          //     socket.friendRequest.splice(index, 1);
          //   }
          // }
        } else if (decData.msg == 'delete') {
          datasetup.removeFriend(socket.name, nick);
          encData = data;
        } else {
          var rec = {'req': 'chat', 'reason': 'Invalid friend msg data', 'data': decData, 'nickname': socket.name};
          datasetup.securityRecord(rec);
          socket.emit('wrong', AESCrypt.socketEncrypt(rec));

          socket.disconnect();
          return;
        }

        socket.emit('chat', encData);
        if(userSocket){
          userSocket.emit('chat', encData);
        }
      }
    }
  }
});

socket.on('move', function(data) {
  try {
    var decData = AESCrypt.socketDecrypt(data);
  } catch (error) {
    console.log('error:'+error);
    var rec = {'req': 'move', 'reason': 'Invalid data', 'error': erro, 'nickname': socket.name};
    datasetup.securityRecord(rec);

    socket.emit('wrong', AESCrypt.socketEncrypt(rec));
    socket.disconnect();
    return;
  }
  if (socket.name == undefined) {
    var rec = {'req': 'move', 'reason': 'not_logined', 'data': decData};
    datasetup.securityRecord(rec);

    socket.emit('wrong', AESCrypt.socketEncrypt(rec));
    socket.disconnect();
    return;
  }
  if (userList[socket.name] == undefined) {
    var rec = {'req': 'move', 'reason': 'no user', 'data': decData, 'nickname': socket.name};
    datasetup.securityRecord(rec);

    socket.emit('wrong', AESCrypt.socketEncrypt(rec));
    socket.disconnect();
    return;
  }

  decData['nickname'] = socket.name;

  if (socket.room == undefined) {
    return;
  }

  if (socket.room.includes('@channel')) {
    if (decData.pos_x == undefined || decData.pos_x < -1200 || decData.pos_x > 1200
    || decData.pos_y == undefined || decData.pos_y < -746.25 || decData.pos_y > 716.25) {
      // var rec = {'req': 'move', 'reason': 'Invalid position value', 'data': decData, 'nickname': socket.name, 'room': socket.room};
      // datasetup.securityRecord(rec);

      // socket.emit('wrong', AESCrypt.socketEncrypt(rec));
      // socket.disconnect();
      return;
    }
    // console.log(decData.pos_x +"/"+ decData.pos_y);
    if (decData.pos_x < -677.505 && decData.pos_y > 619.351
      || (decData.pos_x > 373.65 && decData.pos_y > 690.6)){ //&& !(decData.pos_x < 700.1464 && decData.pos_y < 1351.9114 - decData.pos_x))
    //   || decData.pos_x > -502 && decData.pos_x < 392.2 && decData.pos_y > 152.3 && decData.pos_y < 579.1) {
      // var rec = {'req': 'move', 'reason': 'Invalid position value', 'data': decData, 'nickname': socket.name, 'room': socket.room};
      // datasetup.securityRecord(rec);

      // socket.emit('wrong', AESCrypt.socketEncrypt(rec));
      // socket.disconnect();
      return;
    }

    if (channelList[socket.room] == undefined) {
      var rec = {'req': 'move', 'reason': 'no channel', 'data': decData, 'nickname': socket.name};
      datasetup.securityRecord(rec);

      socket.emit('wrong', AESCrypt.socketEncrypt(rec));
      socket.disconnect();
      return;
    } else if (channelList[socket.room].users[socket.name] == undefined) {
      var rec = {'req': 'move', 'reason': 'not included in channel', 'data': decData, 'nickname': socket.name};
      datasetup.securityRecord(rec);

      socket.emit('wrong', AESCrypt.socketEncrypt(rec));
      socket.disconnect();
      return;
    }

    channelList[socket.room].users[socket.name].x = decData.pos_x;
    channelList[socket.room].users[socket.name].y = decData.pos_y;
  } else if(socket.room.includes('@foothold')){
    if(decData.pos_x == undefined || decData.pos_x < -300 || decData.pos_x > 300
    || decData.pos_y == undefined || decData.pos_y < -450 || decData.pos_y > 420){
      // var rec = {'req': 'move', 'reason': 'Invalid position value', 'data': decData, 'nickname': socket.name, 'room': socket.room};
      // datasetup.securityRecord(rec);

      // socket.emit('wrong', AESCrypt.socketEncrypt(rec));
      // socket.disconnect();
      return;
    }

    if(footholdList[socket.room] == undefined){
      var rec = {'req': 'move', 'reason': 'no foothold room', 'data': decData, 'nickname': socket.name};
      datasetup.securityRecord(rec);

      socket.emit('wrong', AESCrypt.socketEncrypt(rec));
      socket.disconnect();
      return;
    }else if(footholdList[socket.room].userList[socket.name] == undefined){
      var rec = {'req': 'move', 'reason': 'not included in foothold', 'data': decData, 'nickname': socket.name};
      datasetup.securityRecord(rec);

      socket.emit('wrong', AESCrypt.socketEncrypt(rec));
      socket.disconnect();
      return;
    }

    footholdList[socket.room].userList[socket.name].x = decData.pos_x;
    footholdList[socket.room].userList[socket.name].y = decData.pos_y;
  } else if(socket.room.includes('@piano')){
    if(decData.pos_x == undefined || decData.pos_x < -300 || decData.pos_x > 300
      || decData.pos_y == undefined || decData.pos_y < -336 || decData.pos_y > 306){
        return;
      }

    //set pos at pianoList
    if(pianoList[socket.room] == undefined){
      var rec = {'req': 'move', 'reason': 'no piano room', 'data': decData, 'nickname': socket.name};
      datasetup.securityRecord(rec);

      socket.emit('wrong', AESCrypt.socketEncrypt(rec));
      socket.disconnect();
      return;
    }else if(pianoList[socket.room][socket.name] == undefined){
      var rec = {'req': 'move', 'reason': 'not included in piano', 'data': decData, 'nickname': socket.name};
      datasetup.securityRecord(rec);

      socket.emit('wrong', AESCrypt.socketEncrypt(rec));
      socket.disconnect();
      return;
    }

    pianoList[socket.room][socket.name].x = decData.pos_x;
    pianoList[socket.room][socket.name].y = decData.pos_y;

    
  } else {
    if (decData.pos_x == undefined || decData.pos_x < -263.29 || decData.pos_x > 263.29
    || decData.pos_y == undefined || decData.pos_y < -247.63 || decData.pos_y > 217.63) {
      // var rec = {'req': 'move', 'reason': 'Invalid position value', 'data': decData, 'nickname': socket.name, 'room': socket.room};
      // datasetup.securityRecord(rec);

      // socket.emit('wrong', AESCrypt.socketEncrypt(rec));
      // socket.disconnect();
      return;
    }

    if(socket.room.includes('@slot')){
      if(slotList[socket.room] == undefined){
        var rec = {'req': 'move', 'reason': 'no slot room', 'data': decData, 'nickname': socket.name};
        datasetup.securityRecord(rec);
  
        socket.emit('wrong', AESCrypt.socketEncrypt(rec));
        socket.disconnect();
        return;
      }else if(slotList[socket.room][socket.name] == undefined){
        var rec = {'req': 'move', 'reason': 'not included in slot', 'data': decData, 'nickname': socket.name};
        datasetup.securityRecord(rec);
  
        socket.emit('wrong', AESCrypt.socketEncrypt(rec));
        socket.disconnect();
        return;
      }

      slotList[socket.room][socket.name].x = decData.pos_x;
      slotList[socket.room][socket.name].y = decData.pos_y;
    }else{
      if(roomList[socket.room] == undefined){
        var rec = {'req': 'move', 'reason': 'no visit room', 'data': decData, 'nickname': socket.name};
        datasetup.securityRecord(rec);

        socket.emit('wrong', AESCrypt.socketEncrypt(rec));
        socket.disconnect();
        return;
      }else if(roomList[socket.room][socket.name] == undefined){
        var rec = {'req': 'move', 'reason': 'not a guest', 'data': decData, 'nickname': socket.name};
        datasetup.securityRecord(rec);

        socket.emit('wrong', AESCrypt.socketEncrypt(rec));
        socket.disconnect();
        return;
      }
      
      roomList[socket.room][socket.name].x = decData.pos_x;
      roomList[socket.room][socket.name].y = decData.pos_y;
    }
  }

  io.to(socket.room).emit('move', AESCrypt.socketEncrypt(decData));
});

socket.on('square', function() {
  if (socket.name == undefined) {
    var rec = {'req': 'square', 'reason': 'not_logined'};
    datasetup.securityRecord(rec);

    socket.emit('wrong', AESCrypt.socketEncrypt(rec));
    socket.disconnect();
    return;
  }

  var room;
  if(socket.room != undefined){
    if(socket.room.includes('@channel')
      || socket.room.includes('@slot')){
      room = socket.room;
    }else if(socket.room.includes('@blinddate')
    || socket.room.includes('@dice')
    || socket.room.includes('@foothold')
    || socket.room.includes('@fishing')){
      var rec = {'req': 'square', 'reason': 'Invalid request from room', nickname:socket.name};
      datasetup.securityRecord(rec);

      socket.emit('wrong', AESCrypt.socketEncrypt(rec));
      socket.disconnect();
      return;
    }

    if(leaveRoom(socket)){
      return;
    }
  }

  var roomId, newRoomId;
  var keyList = Object.keys(channelList);
  var last;
  if(keyList.length > 0){
    last = keyList[keyList.length-1];
    last = last.slice(8, last.length);
    last = parseInt(last)+1;
  }

  // find room randomly
  //except full room
  let keyLength = keyList.length;
  if(last != undefined){
    for (var i=last-1; i>=0; i--) {
      let key = '@channel'+i;
      let key_index = keyList.indexOf(key);
      if(channelList[key] == undefined && newRoomId == undefined){
        newRoomId = key;
      }else if (key_index >= 0 && Object.keys(channelList[key].users).length >= 20) {
        keyList.splice(key_index,1);
      }
    }
  }

  if(room != undefined && room.includes('@channel')){
    // except current room
    var index = keyList.indexOf(room);
    if(index >= 0){
      keyList.splice(index, 1);
    }
  }
  
  //choose room id
  if(keyList.length == 0){
    if(newRoomId == undefined){
      roomId = '@channel'+keyLength;
    }else{
      roomId = newRoomId;
    }
  }else{
    roomId = keyList[Math.floor(Math.random()*keyList.length)];
  }
  
  var squareLoc;
  if(room != undefined && room.includes('@slot')){
    squareLoc = JSON.parse(JSON.stringify(squareLocList[1]));
  }else{
    squareLoc = JSON.parse(JSON.stringify(squareLocList[0]));
  }

  var userData = {};
  var userDatas = {};
  if (channelList[roomId] == undefined) {
    channelList[roomId] = {};
    channelList[roomId]['users'] = {};
    channelList[roomId]['fashion'] = {};
    channelList[roomId].fashion['waitList'] = [];
    channelList[roomId].fashion['scoreList'] = {};

    socket.room = roomId;
    socket.join(roomId);
    channelList[roomId].users[socket.name] = squareLoc;

    userDatas['result'] = 'success';
    userDatas['room'] = roomId;
    userDatas['squareLoc'] = squareLoc;
    socket.emit('square', AESCrypt.socketEncrypt(userDatas));

  } else {
    var nicknames = Object.keys(channelList[roomId].users);
    datasetup.getUserFromNick(socket.name, function(err, res) {
      if (err) {
        userData['result'] = 'fail';
        userData['err'] = err;
        socket.emit('square', AESCrypt.socketEncrypt(userData));
      } else {
        res[0].cash = String(res[0].cash);
        userData['result'] = 'success';
        res[0]['x'] = squareLoc.x;
        res[0]['y'] = squareLoc.y;
        userData['userData'] = res[0];
        //TODO database
        datasetup.getUsersFromNick(nicknames, function(err, res) {
          if (err) {
            userDatas['result'] = 'fail';
            userDatas['err'] = err;
            socket.emit('square', AESCrypt.socketEncrypt(userDatas));
          } else {
            //code for async query
            userDatas['result'] = 'success';
            userDatas['room'] = roomId;
            for (var j=res.length-1; j>=0; j--) {
              res[j].cash = String(res[j].cash);
              res[j]['x'] = channelList[roomId].users[res[j].nickname].x;
              res[j]['y'] = channelList[roomId].users[res[j].nickname].y;
            }
            userDatas['userData'] = res;
            userDatas['squareLoc'] = squareLoc;

            socket.room = roomId;
            socket.join(roomId);
            channelList[roomId].users[socket.name] = squareLoc;

            io.to(roomId).emit('square', AESCrypt.socketEncrypt(userData));
            socket.emit('square', AESCrypt.socketEncrypt(userDatas));
          }
        });
      }
    });
  }
});

function leaveRoom(socket, decData){
  if (socket == undefined) {
    var rec = {'req': 'leaveRoom', 'reason': 'no user'};
    if(decData){
      rec['data'] = decData;
    }
    datasetup.securityRecord(rec);
    return true;
  }
  if (socket.name == undefined) {
    var rec = {'req': 'leaveRoom', 'reason': 'not_logined'};
    if(decData){
      rec['data'] = decData;
    }
    datasetup.securityRecord(rec);
    socket.emit('wrong', AESCrypt.socketEncrypt(rec));
    socket.disconnect();
    return true;
  }

  var toRoom = {nickname: socket.name};
  var isSend = true;

  socket.leave(socket.room);
  if (socket.room.includes('@channel')) {
    if (channelList[socket.room] == undefined) {
      var rec = {'req': 'leaveRoom', 'reason': 'no room', "nickname": socket.name};
      if(decData){
        rec['data'] = decData;
      }
      datasetup.securityRecord(rec);

      socket.emit('wrong', AESCrypt.socketEncrypt(rec));
      socket.disconnect();
      return true;
    }

    var isCanceled = false;
    var index = channelList[socket.room].fashion.waitList.indexOf(socket.name);
    if (index >= 0) {
      if (channelList[socket.room].fashion.timer == undefined) {
        isCanceled = true;
        channelList[socket.room].fashion.waitList.splice(index, 1);
      }else{
        var timerArgs = channelList[socket.room].fashion.timer._timerArgs;
        let user = timerArgs[0];
        if (user.nickname == socket.name) {
          clearTimeout(channelList[socket.room].fashion.timer);
          fashionshow_end(timerArgs[0],timerArgs[1]);
        }else{
          isCanceled = true;
          channelList[socket.room].fashion.waitList.splice(index, 1);
        }
      }
    }

    if(isCanceled){
      var resData = {result: 'success', type: 'cancel', nickname: socket.name};
      io.to(socket.room).emit('fashionshow', AESCrypt.socketEncrypt(resData));
    }

    delete channelList[socket.room].users[socket.name];
    if (Object.keys(channelList[socket.room].users).length == 0) {
      delete channelList[socket.room];
      isSend = false;
    }
  } else if(socket.room.includes('@dice')){
    if(diceList[socket.room] == undefined){
      var rec = {'req': 'leaveRoom', 'reason': 'no room', "nickname": socket.name};
      if(decData){
        rec['data'] = decData;
      }
      datasetup.securityRecord(rec);

      socket.emit('wrong', AESCrypt.socketEncrypt(rec));
      socket.disconnect();
      return true;
    }

    delete diceList[socket.room].locList[socket.name];
    if(Object.keys(diceList[socket.room].locList).length == 0){
      clearInterval(diceList[socket.room].timer);
      delete diceList[socket.room];
      isSend = false;
    }
  } else if(socket.room.includes('@blinddate')){
    if(blinddateList[socket.room] == undefined){
      var rec = {'req': 'leaveRoom', 'reason': 'no room', "nickname": socket.name};
      if(decData){
        rec['data'] = decData;
      }
      datasetup.securityRecord(rec);

      socket.emit('wrong', AESCrypt.socketEncrypt(rec));
      socket.disconnect();
      return true;
    }

    if(blinddateList[socket.room].userList.length == 2){
      var partner;
      if(socket.name == blinddateList[socket.room].userList[0]){
        partner = blinddateList[socket.room].userList[1];
      }else{
        partner = blinddateList[socket.room].userList[0];
      }
      if(userList[partner] == undefined){
        var rec = {'req': 'leaveRoom', 'reason': 'no room', "nickname": partner};
        if(decData){
          rec['data'] = decData;
        }
        datasetup.securityRecord(rec);
        delete socket.room;
        return true;
      }

      delete userList[partner].room;
      userList[partner].leave(socket.room);
      userList[partner].emit('home', AESCrypt.socketEncrypt(toRoom));
    }
    
    isSend = false;
    delete blinddateList[socket.room];
  } else if(socket.room.includes('@foothold')){
    if(footholdList[socket.room] == undefined){
      var rec = {'req': 'leaveRoom', 'reason': 'no room', "nickname": socket.name};
      if(decData){
        rec['data'] = decData;
      }
      datasetup.securityRecord(rec);
      socket.emit('wrong', AESCrypt.socketEncrypt(rec));
      return true;
    }

    delete footholdList[socket.room].userList[socket.name];
    for(var i=0; i<footholdList[socket.room].indexList.length; i++){
      if(footholdList[socket.room].indexList[i] == socket.name){
        delete footholdList[socket.room].indexList[i];
        break;
      }
    }
    if (Object.keys(footholdList[socket.room].userList).length == 0) {
      clearTimeout(footholdList[socket.room].timer);
      delete footholdList[socket.room];
      isSend = false;
    }
  } else if(socket.room.includes('@slot')){
    if(slotList[socket.room] == undefined){
      var rec = {'req': 'leaveRoom', 'reason': 'no room', "nickname": socket.name};
      if(decData){
        rec['data'] = decData;
      }
      datasetup.securityRecord(rec);
      socket.emit('wrong', AESCrypt.socketEncrypt(rec));
      return true;
    }

    delete slotList[socket.room][socket.name];
    if(Object.keys(slotList[socket.room]).length == 0){
      delete slotList[socket.room];
      isSend = false;
    }
  } else if(socket.room.includes('@fishing')){
    if(fishingList[socket.room] == undefined){
      var rec = {'req': 'leaveRoom', 'reason': 'no room', "nickname": socket.name};
      if(decData){
        rec['data'] = decData;
      }
      datasetup.securityRecord(rec);
      socket.emit('wrong', AESCrypt.socketEncrypt(rec));
      return true;
    }else if(fishingList[socket.room][socket.name] == undefined){
      var rec = {'req': 'leaveRoom', 'reason': 'not in the room', "nickname": socket.name};
      if(decData){
        rec['data'] = decData;
      }
      datasetup.securityRecord(rec);
      socket.emit('wrong', AESCrypt.socketEncrypt(rec));
      return true;
    }

    clearTimeout(fishingList[socket.room][socket.name].timer);
    delete fishingList[socket.room][socket.name];
    if(Object.keys(fishingList[socket.room]).length == 0){
      delete fishingList[socket.room];
      isSend = false;
    }
  } else if(socket.room.includes('@piano')){
    if(pianoList[socket.room] == undefined){
      var rec = {'req': 'leaveRoom', 'reason': 'no room', "nickname": socket.name};
      if(decData){
        rec['data'] = decData;
      }
      datasetup.securityRecord(rec);
      socket.emit('wrong', AESCrypt.socketEncrypt(rec));
      return true;
    }

    delete pianoList[socket.room][socket.name];
    if(Object.keys(pianoList[socket.room]).length == 0){
      delete pianoList[socket.room];
      isSend = false;
    }
  } else if (socket.room == socket.name) {
    if (roomList[socket.room] == undefined) {
      var rec = {'req': 'leaveRoom', 'reason': 'no visit room', "nickname": socket.name};
      if(decData){
        rec['data'] = decData;
      }
      datasetup.securityRecord(rec);

      socket.emit('wrong', AESCrypt.socketEncrypt(rec));
      socket.disconnect();
      return true;
    }

    toRoom['msg'] = 'leave';
    io.to(socket.room).emit('visit', AESCrypt.socketEncrypt(toRoom));

    delete roomList[socket.room][socket.name];
    var guests = Object.keys(roomList[socket.room]);
    for (var i=0; i<guests.length; i++) {
      if (userList[guests[i]] == undefined) {
        var rec = {'req': 'leaveRoom', 'reason': 'no user', "nickname": guests[i]};
        if(decData){
          rec['data'] = decData;
        }
        datasetup.securityRecord(rec);
        continue;
      }
      delete userList[guests[i]].room;
      userList[guests[i]].leave(socket.room);
    }
    delete roomList[socket.room];
    isSend = false;
  } else if(socket.room.includes('@hangman')){
    if(hangmanList[socket.room] == undefined){
      var rec = {'req': 'disconnect', 'reason': 'no room', "nickname": socket.name};
      datasetup.securityRecord(rec);

      socket.emit('wrong', AESCrypt.socketEncrypt(rec));
      delete userList[socket.name];
      return;
    }

    socket.leave(socket.room);

    if(hangmanList[socket.room].userList[socket.name].timer){
      clearTimeout(hangmanList[socket.room].userList[socket.name].timer);
      // delete hangmanList[socket.room].userList[socket.name].timer;
    }
    delete hangmanList[socket.room].userList[socket.name];
    for(var i=0; i<hangmanList[socket.room].indexList.length; i++){
      if(hangmanList[socket.room].indexList[i] == socket.name){
        delete hangmanList[socket.room].indexList[i];
        break;
      }
    }
    if (Object.keys(hangmanList[socket.room].userList).length == 0) {
      clearTimeout(hangmanList[socket.room].timer);
      delete hangmanList[socket.room].timer;
      delete hangmanList[socket.room];
      isSend = false;
    }
  } else if(socket.room.includes('@running')){
    if(runningList[socket.room] == undefined){
      var rec = {'req': 'leaveRoom', 'reason': 'no room', "nickname": socket.name};
      if(decData){
        rec['data'] = decData;
      }
      datasetup.securityRecord(rec);
      socket.emit('wrong', AESCrypt.socketEncrypt(rec));
      return true;
    }

    if(runningList[socket.room].userList[socket.name].timer){
      clearTimeout(runningList[socket.room].userList[socket.name].timer);
    }
    delete runningList[socket.room].userList[socket.name];
    if (Object.keys(runningList[socket.room].userList).length == 0) {
      if(runningList[socket.room].timer._turn == 'bet'){
        clearTimeout(runningList[socket.room].timer);
      }else if(runningList[socket.room].timer._turn == 'game'){
        clearImmediate(runningList[socket.room].timer);
      }
      
      delete runningList[socket.room];
      isSend = false;
    }
  } else {
    var master = userList[socket.room];
    if (master == undefined) {
      var rec = {'req': 'leaveRoom', 'reason': 'no master user', "nickname": socket.name};
      if(decData){
        rec['data'] = decData;
      }
      datasetup.securityRecord(rec);

      socket.emit('wrong', AESCrypt.socketEncrypt(rec));
      socket.disconnect();
      return true;
    } else if (roomList[socket.room] == undefined) {
      var rec = {'req': 'leaveRoom', 'reason': 'no visit room', "nickname": socket.name};
      if(decData){
        rec['data'] = decData;
      }
      datasetup.securityRecord(rec);

      socket.emit('wrong', AESCrypt.socketEncrypt(rec));
      socket.disconnect();
      return true;
    }

    delete roomList[socket.room][socket.name];
    if (Object.keys(roomList[socket.room]).length <= 1) {
      toRoom['isSolo'] = true;
      delete roomList[socket.room];
      delete master.room;
    }
  }

  if(isSend){
    io.to(socket.room).emit('home', AESCrypt.socketEncrypt(toRoom));
  }
  delete socket.room;
  return false;
}

socket.on('visit', function(data) {
  try {
    var decData = AESCrypt.socketDecrypt(data);
  } catch (error) {
    console.log('error:'+error);
    var rec = {'req': 'visit', 'reason': 'Invalid data', 'error': error, 'nickname': socket.name};
    datasetup.securityRecord(rec);

    socket.emit('wrong', AESCrypt.socketEncrypt(rec));
    socket.disconnect();
    return;
  }
  console.log('visit '+JSON.stringify(decData));

  if (socket.name == undefined) {
    var rec = {'req': 'visit', 'reason': 'not_logined', 'data': decData, 'nickname': socket.name};
    datasetup.securityRecord(rec);

    socket.emit('wrong', AESCrypt.socketEncrypt(rec));
    socket.disconnect();
    return;
  }

  var partner = userList[decData.to];
  if (partner == undefined || partner.name == undefined) {
    decData['result'] = 'no_user';
    socket.emit('visit', AESCrypt.socketEncrypt(decData));
    return;
  }

  if (decData.msg == 'request') {
    if(socket.room != undefined){
      if(socket.room == partner.name){
        //block re-request
        return;
      }
    }
    decData['from'] = socket.name;
    decData['sendTime'] = new Date().toFormat('YYYY-MM-DD HH24:MI:SS');
    partner.emit('visit', AESCrypt.socketEncrypt(decData));

  } else if (decData.msg == 'accept') {
    //guest in dice, foothold, blinddate
    if(partner.room != undefined){
      if(partner.isAd
        || partner.room.includes('@channel')
        && channelList[partner.room] != undefined
        && channelList[partner.room].fashion.waitList[partner.name] != undefined
        || partner.room.includes('@dice')
        || partner.room.includes('@foothold')
        || partner.room.includes('@blinddate')
        || partner.room.includes('@fishing')
        || partner.room.includes('@hangman')
        || partner.room.includes('@running')){
          decData.msg = 'busy';
          decData.from = decData.to;
          decData.to = socket.name;
          socket.emit('visit', AESCrypt.socketEncrypt(decData));
          return;
      }else if(partner.room == socket.name){
        //block re-accept
        return;
      }
      
      if(leaveRoom(partner, decData)){
        return;
      }
    }

    if (roomList[socket.name] == undefined) {
      if(decData.pos_x == undefined || decData.pos_y == undefined){
        decData.pos_x = 0;
        decData.pos_y = 0;
      }
      roomList[socket.name] = {};
      roomList[socket.name][socket.name] = {x: decData.pos_x, y: decData.pos_y};
    }

    var userData = {};
    var userDatas = {};
    var nicknames = Object.keys(roomList[socket.name]);
    datasetup.getUserFromNick(decData.to, function(err, res) {
      if (err) {
        userData['msg'] = 'fail';
        userData['err'] = err;
        socket.emit('visit', AESCrypt.socketEncrypt(userData));
      } else {
        res[0].cash = String(res[0].cash);
        userData['msg'] = 'accept';
        userData['master'] = socket.name;
        res[0]['x'] = 0;
        res[0]['y'] = 0;
        userData['userData'] = res[0];
        //TODO database
        datasetup.getUsersFromNick(nicknames, function(err, res) {
          if (err) {
            userDatas['msg'] = 'fail';
            userDatas['err'] = err;
            socket.emit('visit', AESCrypt.socketEncrypt(userDatas));
          } else {
            for (var j=0; j<res.length; j++) {
              res[j].cash = String(res[j].cash);
              res[j]['x'] = roomList[socket.name][res[j].nickname].x;
              res[j]['y'] = roomList[socket.name][res[j].nickname].y;
            }
            userDatas['userData'] = res;

            datasetup.getCurrentFurnitures(socket.name, true, function(err, res) {
              if (err) {
                userDatas['msg'] = 'fail';
                userDatas['err'] = err;
                socket.emit('visit', AESCrypt.socketEncrypt(res));
              } else {
                userDatas['msg'] = 'accept';
                userDatas['master'] = socket.name;
                userDatas['furnitureData'] = res;

                if (socket.room != undefined && socket.room != socket.name) {
                  if(leaveRoom(socket, decData)){
                    return;
                  }
                }

                if(socket.room == undefined){
                  socket.join(socket.name);
                  socket.room = socket.name;
                }
                io.to(socket.name).emit('visit', AESCrypt.socketEncrypt(userData));
                partner.emit('visit', AESCrypt.socketEncrypt(userDatas));
                partner.join(socket.name);
                partner.room = socket.name;
                roomList[socket.name][decData.to] = {x: 0, y: 0};
              }
            });
          }
        });
      }
    });
  } else {
    console.log('visit msg error');
    var rec = {'req': 'visit', 'reason': 'Invalid visit msg data', 'data': decData, 'nickname': socket.name};
    datasetup.securityRecord(rec);
    socket.emit('wrong', AESCrypt.socketEncrypt(rec));

    socket.disconnect();
    return;
  }
});

socket.on('block', function(data) {
  try {
    var decData = AESCrypt.socketDecrypt(data);
  } catch (error) {
    console.log('error:'+error);
    var rec = {'req': 'block', 'reason': 'Invalid data', 'error': error, 'nickname': socket.name};
    datasetup.securityRecord(rec);

    socket.emit('wrong', AESCrypt.socketEncrypt(rec));
    socket.disconnect();
    return;
  }

  if (socket.name == undefined) {
    var rec = {'req': 'block', 'reason': 'not_logined', 'data': decData};
    datasetup.securityRecord(rec);
    socket.emit('wrong', AESCrypt.socketEncrypt(rec));
    socket.disconnect();
    return;
  }

  if (decData.nickname == undefined) {
    console.log('nickname error');
    var rec = {'req': 'block', 'reason': 'nickname undefined', 'data': decData, 'nickname': socket.name};
    datasetup.securityRecord(rec);
    socket.emit('wrong', AESCrypt.socketEncrypt(rec));

    socket.disconnect();
    return;
  }

  var nick = decData.nickname.trim();
  if (nick.includes(' ') || nick.includes('@') || nick.includes('/') || nick.includes('\\') || nick.includes('"') || nick.length < 1 || nick.length > 12) {
      console.log('nickname error');
      var rec = {'req': 'block', 'reason': 'Invalid nickname data', 'data': decData, 'nickname': socket.name};
      datasetup.securityRecord(rec);
      socket.emit('wrong', AESCrypt.socketEncrypt(rec));

      socket.disconnect();
      return;
  }

  datasetup.block(socket.name, nick, function(err, data) {
    if (err) {
      decData['result'] = 'fail';
      decData['error'] = err;
      socket.emit('block', AESCrypt.socketEncrypt(decData));
    } else {
      datasetup.getUserFromNick(nick, function(err, data){
        if(err){
          decData['result'] = 'fail';
          decData['error'] = err;
        }else{
          decData['result'] = 'success';
          decData['userData'] = data[0];
        }
        socket.emit('block', AESCrypt.socketEncrypt(decData));
      });
    }
  });
});

socket.on('unblock', function(data) {
  try {
    var decData = AESCrypt.socketDecrypt(data);
  } catch (error) {
    console.log('error:'+error);
    var rec = {'req': 'unblock', 'reason': 'Invalid data', 'error': error, 'nickname': socket.name};
    datasetup.securityRecord(rec);

    socket.emit('wrong', AESCrypt.socketEncrypt(rec));
    socket.disconnect();
    return;
  }

  if (socket.name == undefined) {
    var rec = {'req': 'unblock', 'reason': 'not_logined', 'data': decData};
    datasetup.securityRecord(rec);
    socket.emit('wrong', AESCrypt.socketEncrypt(rec));
    socket.disconnect();
    return;
  }

  if (decData.nickname == undefined) {
    console.log('nickname error');
    var rec = {'req': 'unblock', 'reason': 'nickname undefined', 'data': decData, 'nickname': socket.name};
    datasetup.securityRecord(rec);
    socket.emit('wrong', AESCrypt.socketEncrypt(rec));

    socket.disconnect();
    return;
  }

  var nick = decData.nickname.trim();
  if (nick.includes(' ') || nick.includes('@') || nick.includes('/') || nick.includes('\\') || nick.includes('"') || nick.length < 1 || nick.length > 12) {
      console.log('nickname error');
      var rec = {'req': 'unblock', 'reason': 'Invalid nickname data', 'data': decData, 'nickname': socket.name};
      datasetup.securityRecord(rec);
      socket.emit('wrong', AESCrypt.socketEncrypt(rec));

      socket.disconnect();
      return;
  }

  datasetup.unblock(socket.name, nick, function(err, data) {
    if (err) {
      decData['result'] = 'fail';
      decData['error'] = err;
    } else {
      decData['result'] = 'success';
    }
    socket.emit('unblock', AESCrypt.socketEncrypt(decData));
  });
});

socket.on('home', function() {
  if (socket.name == undefined) {
    var rec = {'req': 'home', 'reason': 'not_logined'};
    datasetup.securityRecord(rec);

    socket.emit('wrong', AESCrypt.socketEncrypt(rec));
    socket.disconnect();
    return;
  }

  var toUser = {result: 'success'};
  if (socket.room == undefined) {
    socket.emit('home', AESCrypt.socketEncrypt(toUser));
    return;
  }

  if (socket.name == socket.room) {
    var rec = {'req': 'home', 'reason': 'user is master', "nickname": socket.name};
    datasetup.securityRecord(rec);

    socket.emit('wrong', AESCrypt.socketEncrypt(rec));
    socket.disconnect();
    return;
  }

  if(leaveRoom(socket))
    return;

  socket.emit('home', AESCrypt.socketEncrypt(toUser));
});

socket.on('getFurnitures', function() {
  if (socket.name == undefined) {
    var rec = {'req': 'getFurnitures', 'reason': 'not_logined'};
    datasetup.securityRecord(rec);

    socket.emit('wrong', AESCrypt.socketEncrypt(rec));
    socket.disconnect();
    return;
  }
  if (socket.room != undefined && socket.room != socket.name) {
    var rec = {'req': 'getFurnitures', 'reason': 'not in house', "nickname": socket.name};
    datasetup.securityRecord(rec);

    socket.emit('wrong', AESCrypt.socketEncrypt(rec));
    socket.disconnect();
    return;
  }

  datasetup.getFurnitures(socket.name, function(err, data) {
    var resData = {};
    if (err) {
      resData['result'] = 'fail';
      resData['error'] = err;
    } else {
      resData['result'] = 'success';
      resData['furnitureData'] = data;
    }
    socket.emit('getFurnitures', AESCrypt.socketEncrypt(resData));
  });
});

socket.on('addFurniture', function(data) {
  try {
    var decData = AESCrypt.socketDecrypt(data);
  } catch (error) {
    console.log('error:'+error);
    var rec = {'req': 'addFurniture', 'reason': 'Invalid data', 'error': error, 'nickname': socket.name};
    datasetup.securityRecord(rec);

    socket.emit('wrong', AESCrypt.socketEncrypt(rec));
    socket.disconnect();
    return;
  }

  if (socket.name == undefined) {
    var rec = {'req': 'addFurniture', 'reason': 'not_logined', 'data': decData};
    datasetup.securityRecord(rec);

    socket.emit('wrong', AESCrypt.socketEncrypt(rec));
    socket.disconnect();
    return;
  }
  if (socket.room != undefined && socket.room != socket.name) {
    var rec = {'req': 'addFurnitures', 'reason': 'not in house', "data": decData, "nickname": socket.name};
    datasetup.securityRecord(rec);

    socket.emit('wrong', AESCrypt.socketEncrypt(rec));
    socket.disconnect();
    return;
  }

  try{
    var param = JSON.parse(JSON.stringify(decData));
  }catch(error){
    console.log('error:'+error);
    var rec = {'req': 'login', 'reason': 'parsing error', 'error': error};
    datasetup.securityRecord(rec);

    socket.emit('wrong', AESCrypt.socketEncrypt(rec));
    socket.disconnect();
    return;
  }
  
  if (param.furniture_type < 0 && param.furniture_num == 0) {
    var rec = {'req': 'addFurniture', 'reason': 'add default furniture', "nickname": socket.name, "data": decData};
    datasetup.securityRecord(rec);

    socket.emit('wrong', AESCrypt.socketEncrypt(rec));
    socket.disconnect();
    return;
  }

  datasetup.checkFurniture(socket.name, param, function(err, res) {
    if (err) {
      decData['result'] = 'fail';
      decData['error'] = err;
      socket.emit('addFurniture', AESCrypt.socketEncrypt(decData));
    } else {
      if (res.length > 0) {
        decData['result'] = 'have_item';
        socket.emit('addFurniture', AESCrypt.socketEncrypt(decData));
      } else {
        datasetup.getUserFromNick(socket.name, function(err, res) {
          if (err) {
            decData['result'] = 'fail';
            decData['error'] = err;
            socket.emit('addFurniture', AESCrypt.socketEncrypt(decData));
          } else {
            var cash = res[0].cash;
            res[0].cash = String(res[0].cash);
            var table_num, type;
            if (decData.furniture_type < 0) {
              table_num = datasetup.protocol.table_num.floorNwall;
              if (decData.furniture_type == -1) {
                type = 0;
              } else if (decData.furniture_type == -2) {
                type = 1;
              } else {
                var rec = {'req': 'addFurniture', 'reason': 'Invalid furniture type error', "nickname": socket.name, "data": decData};
                datasetup.securityRecord(rec);

                socket.emit('wrong', AESCrypt.socketEncrypt(rec));
                socket.disconnect();
                return;
              }
            } else {
              table_num = datasetup.protocol.table_num.house;
              type = decData.furniture_type;
            }

            datasetup.getItemPrice(table_num, type, decData.furniture_num, function(err, res) {
              if (err) {
                decData['result'] = 'fail';
                decData['error'] = err;
                socket.emit('addFurniture', AESCrypt.socketEncrypt(decData));
              } else {
                var item_price = res[0].cash;
                if (cash >= item_price) {
                  param = JSON.parse(JSON.stringify(decData));
                  datasetup.addFurniture(socket.name, param, function(err, data) {
                    if (err) {
                      decData['result'] = 'fail';
                      decData['error'] = err;
                      socket.emit('addFurniture', AESCrypt.socketEncrypt(decData));
                    } else {
                      cash -= item_price;
                      datasetup.setUserCash(socket.name, cash, function(err, res) {
                        if (err) {
                          decData['result'] = 'fail';
                          decData['error'] = err;
                          socket.emit('addFurniture', AESCrypt.socketEncrypt(decData));
                        } else {
                          decData['result'] = 'success';
                          decData['cash'] = String(cash);
                          decData['nickname'] = socket.name;
                          if(socket.room){
                            io.to(socket.room).emit('addFurniture', AESCrypt.socketEncrypt(decData));
                          }else{
                            socket.emit('addFurniture', AESCrypt.socketEncrypt(decData));
                          }
                        }
                      });
                    }
                  });
                } else {
                  decData['result'] = 'not_enough_cash';
                  socket.emit('addFurniture', AESCrypt.socketEncrypt(decData));
                }
              }
            });
          }
        });
      }
    }
  });
});

socket.on('setFurnitures', function(data) {
  try {
    var decData = AESCrypt.socketDecrypt(data);
  } catch (error) {
    console.log('error:'+error);
    var rec = {'req': 'setFurnitures', 'reason': 'Invalid data', 'error': error, 'nickname': socket.name};
    datasetup.securityRecord(rec);

    socket.emit('wrong', AESCrypt.socketEncrypt(rec));
    socket.disconnect();
    return;
  }
  console.log('setFurnitures '+JSON.stringify(decData));

  if (socket.name == undefined) {
    var rec = {'req': 'setFurnitures', 'reason': 'not_logined', 'data': decData};
    datasetup.securityRecord(rec);

    socket.emit('wrong', AESCrypt.socketEncrypt(rec));
    socket.disconnect();
    return;
  }
  if (socket.room != undefined && socket.room != socket.name) {
    var rec = {'req': 'setFurnitures', 'reason': 'not in house', "data": decData, "nickname": socket.name};
    datasetup.securityRecord(rec);

    socket.emit('wrong', AESCrypt.socketEncrypt(rec));
    socket.disconnect();
    return;
  }

  decData['nickname'] = socket.name;

  var room = socket.room;
  if (socket.room == undefined) {
    room = socket.id;
  }

  if (decData.changed == undefined || decData.changed.length == 0) {
    decData['result'] = 'success';
    io.to(room).emit('setFurnitures', AESCrypt.socketEncrypt(decData));
  } else {
    try{
      var param = JSON.parse(JSON.stringify(decData.changed));
    }catch(error){
      console.log('error:'+error);
      var rec = {'req': 'login', 'reason': 'parsing error', 'error': error};
      datasetup.securityRecord(rec);
  
      socket.emit('wrong', AESCrypt.socketEncrypt(rec));
      socket.disconnect();
      return;
    }
    
    for (var i=param.length-1; i>=0; i--) {
      if (param[i].furniture_type < 0 && param[i].furniture_num == 0) {
        param.splice(i, 1);
      }
    }

    if (param.length == 0) {
      datasetup.setCurrentFurnitures(socket.name, decData.changed, function(err, data) {
        if (err) {
          decData['result'] = 'fail';
          decData['error'] = err;
          socket.emit('setFurnitures', AESCrypt.socketEncrypt(decData));
        } else {
          decData['result'] = 'success';
          io.to(room).emit('setFurnitures', AESCrypt.socketEncrypt(decData));
        }
      });
    } else {
      datasetup.checkFurnitures(socket.name, param, function(err, res) {
        if (err) {
          decData['result'] = 'fail';
          decData['error'] = err;
          socket.emit('setFurnitures', AESCrypt.socketEncrypt(decData));
        } else {
          if (res.length == param.length) {
            datasetup.setCurrentFurnitures(socket.name, decData.changed, function(err, data) {
              if (err) {
                decData['result'] = 'fail';
                decData['error'] = err;
                socket.emit('setFurnitures', AESCrypt.socketEncrypt(decData));
              } else {
                decData['result'] = 'success';
                io.to(room).emit('setFurnitures', AESCrypt.socketEncrypt(decData));
              }
            });
          } else {
            var rec = {'req': 'setFurnitures', 'reason': 'no furniture', "nickname": socket.name, "data": decData};
            datasetup.securityRecord(rec);

            socket.emit('wrong', AESCrypt.socketEncrypt(rec));
            socket.disconnect();
            return;
          }
        }
      });
    }
  }
});

socket.on('getClothes', function() {
  if (socket.name == undefined) {
    var rec = {'req': 'getClothes', 'reason': 'not_logined'};
    datasetup.securityRecord(rec);

    socket.emit('wrong', AESCrypt.socketEncrypt(rec));
    socket.disconnect();
    return;
  }
  
  datasetup.getClothes(socket.name, function(err, data) {
    var resData = {};
    if (err) {
      resData['result'] = 'fail';
      resData['error'] = err;
    } else {
      resData['result'] = 'success';
      resData['clothData'] = data;
    }
    socket.emit('getClothes', AESCrypt.socketEncrypt(resData));
  });
});

socket.on('addClothes', function(data) {
  try {
    var decData = AESCrypt.socketDecrypt(data);
  } catch (error) {
    console.log('error:'+error);
    var rec = {'req': 'addClothes', 'reason': 'Invalid data', 'error': error, 'nickname': socket.name};
    datasetup.securityRecord(rec);

    socket.emit('wrong', AESCrypt.socketEncrypt(rec));
    socket.disconnect();
    return;
  }

  if (socket.name == undefined) {
    var rec = {'req': 'addClothes', 'reason': 'not_logined', 'data': decData};
    datasetup.securityRecord(rec);

    socket.emit('wrong', AESCrypt.socketEncrypt(rec));
    socket.disconnect();
    return;
  }

  var items = [];
  for (var i=0; i<decData.clothData.length; i++) {
    if (decData.clothData[i].cloth_type == 0 || decData.clothData[i].cloth_num <= 3) {
      var rec = {'req': 'addClothes', 'reason': 'add default cloth', "nickname": socket.name, "data": decData};
      datasetup.securityRecord(rec);

      socket.emit('wrong', AESCrypt.socketEncrypt(rec));
      socket.disconnect();
      return;
    }
    items.push({table_num: datasetup.protocol.table_num.closet, type: decData.clothData[i].cloth_type, num: decData.clothData[i].cloth_num});
  }

  datasetup.checkClothes(socket.name, decData.clothData, function(err, res) {
    if (err) {
      decData['result'] = 'fail';
      decData['error'] = err;
      socket.emit('addClothes', AESCrypt.socketEncrypt(decData));
    } else {
      if (res.length > 0) {
        decData['result'] = 'have_item';
        socket.emit('addClothes', AESCrypt.socketEncrypt(decData));
      } else {
        datasetup.getUserFromNick(socket.name, function(err, res) {
          if (err) {
            decData['result'] = 'fail';
            decData['error'] = err;
            socket.emit('addClothes', AESCrypt.socketEncrypt(decData));
          } else {
            var cash = res[0].cash;
            datasetup.getItemPrices(items, function(err, res) {
              if (err) {
                decData['result'] = 'fail';
                decData['error'] = err;
                socket.emit('addClothes', AESCrypt.socketEncrypt(decData));
              } else {
                if (items.length == res.length) {
                  var item_prices = 0;
                  for (var i=0; i<res.length; i++) {
                    item_prices += res[i].cash;
                  }
                  if (cash >= item_prices) {
                    datasetup.addClothes(socket.name, decData.clothData, function(err, data) {
                      if (err) {
                        decData['result'] = 'fail';
                        decData['error'] = err;
                        socket.emit('addClothes', AESCrypt.socketEncrypt(decData));
                      } else {
                        cash -= item_prices;
                        datasetup.setUserCash(socket.name, cash, function(err, data) {
                          if (err) {
                            decData['result'] = 'fail';
                            decData['error'] = err;
                          } else {
                            decData['result'] = 'success';
                            decData['cash'] = String(cash);
                          }
                          socket.emit('addClothes', AESCrypt.socketEncrypt(decData));
                        });
                      }
                    });
                  } else {
                    decData['result'] = 'not_enough_cash';
                    socket.emit('addClothes', AESCrypt.socketEncrypt(decData));
                  }
                } else {
                  var rec = {'req': 'addClothes', 'reason': 'no item price data', "nickname": socket.name, "data": decData};
                  datasetup.securityRecord(rec);

                  socket.emit('wrong', AESCrypt.socketEncrypt(rec));
                  socket.disconnect();
                  return;
                }
              }
            });
          }
        });
      }
    }
  });
});

socket.on('setClothes', function(data) {
  try {
    var decData = AESCrypt.socketDecrypt(data);
  } catch (error) {
    console.log('error:'+error);
    var rec = {'req': 'setClothes', 'reason': 'Invalid data', 'error': error, 'nickname': socket.name};
    datasetup.securityRecord(rec);

    socket.emit('wrong', AESCrypt.socketEncrypt(rec));
    socket.disconnect();
    return;
  }

  if (socket.name == undefined) {
    var rec = {'req': 'setClothes', 'reason': 'not_logined', 'data': decData};
    datasetup.securityRecord(rec);

    socket.emit('wrong', AESCrypt.socketEncrypt(rec));
    socket.disconnect();
    return;
  }

  if(decData['skin'] >= datasetup.skinLength){
    var rec = {'req': 'setClothes', 'reason': 'Invalid skin data', "data": decData, nickname:socket.name};
    datasetup.securityRecord(rec);

    socket.emit('wrong', AESCrypt.socketEncrypt(rec));
    socket.disconnect();
    return;
  }

  var clothArray = [];
  var clothIndex = Object.keys(datasetup.protocol.cloth_type);
  for (var i=0; i<clothIndex.length; i++) {
    if(decData[clothIndex[i]] == undefined || clothIndex[i] == 'skin' && decData[clothIndex[i]] < 0
    || clothIndex[i] == 'face' && decData[clothIndex[i]] < 0){
      var rec = {'req': 'setClothes', 'reason': 'Invalid data', "data": decData, 'nickname':socket.name};
      datasetup.securityRecord(rec);

      socket.emit('wrong', AESCrypt.socketEncrypt(rec));
      socket.disconnect();
      return;
    }
    
    if (clothIndex[i] != 'skin' && decData[clothIndex[i]] > 3)
      {clothArray.push({cloth_type:i, cloth_num:decData[clothIndex[i]]});}
  }

  var room = socket.room;
  if (socket.room == undefined) {
    room = socket.id;
  }

  if (clothArray.length == 0) {
    datasetup.setClothes(socket.name, decData, function(err, data) {
      if (err) {
        decData['result'] = 'fail';
        decData['error'] = err;
        socket.emit('setClothes', AESCrypt.socketEncrypt(decData));
      } else {
        decData['result'] = 'success';
        decData['nickname'] = socket.name;
        io.to(room).emit('setClothes', AESCrypt.socketEncrypt(decData));
      }
    });
  } else {
    datasetup.checkClothes(socket.name, clothArray, function(err, res) {
      if (err) {
        decData['result'] = 'fail';
        decData['error'] = err;
        socket.emit('setClothes', AESCrypt.socketEncrypt(decData));
      } else {
        if (res.length == clothArray.length) {
          datasetup.setClothes(socket.name, decData, function(err, data) {
            if (err) {
              decData['result'] = 'fail';
              decData['error'] = err;
              socket.emit('setClothes', AESCrypt.socketEncrypt(decData));
            } else {
              decData['result'] = 'success';
              decData['nickname'] = socket.name;
              io.to(room).emit('setClothes', AESCrypt.socketEncrypt(decData));
            }
          });
        } else {
          var rec = {'req': 'setClothes', 'reason': 'no cloth', "nickname": socket.name, "data": decData};
          datasetup.securityRecord(rec);

          socket.emit('wrong', AESCrypt.socketEncrypt(rec));
          socket.disconnect();
          return;
        }
      }
    });
  }
});

socket.on('randomCloth', function(data) {
  try {
    var decData = AESCrypt.socketDecrypt(data);
  } catch (error) {
    console.log('error:'+error);
    var rec = {'req': 'randomCloth', 'reason': 'Invalid data', 'error': error, 'nickname': socket.name};
    datasetup.securityRecord(rec);

    socket.emit('wrong', AESCrypt.socketEncrypt(rec));
    socket.disconnect();
    return;
  }

  if (socket.name == undefined) {
    var rec = {'req': 'randomCloth', 'reason': 'not_logined', 'data':decData};
    datasetup.securityRecord(rec);

    socket.emit('wrong', AESCrypt.socketEncrypt(rec));
    socket.disconnect();
    return;
  }

  if(decData.itemNum == undefined || decData.itemNum < 1 || decData.itemNum > 5){
    var rec = {'req': 'randomCloth', 'reason': 'Invalid itemNum data', data:decData, nickname:socket.name};
    datasetup.securityRecord(rec);

    socket.emit('wrong', AESCrypt.socketEncrypt(rec));
    socket.disconnect();
    return;
  }

  datasetup.getUserFromNick(socket.name, function(err, data) {
    var resData = {};
    if (err) {
      resData['result'] = 'fail';
      resData['error'] = err;
      socket.emit('randomCloth', AESCrypt.socketEncrypt(resData));
    } else {
      var cash = data[0].cash;
      if (cash >= 500*decData.itemNum) {
        datasetup.getItems(true, function(err, data) {
          if (err) {
            resData['result'] = 'fail';
            resData['error'] = err;
            socket.emit('randomCloth', AESCrypt.socketEncrypt(resData));
          } else {
            var items = data;
            datasetup.getClothes(socket.name, function(err, data) {
              if (err) {
                resData['result'] = 'fail';
                resData['error'] = err;
                socket.emit('randomCloth', AESCrypt.socketEncrypt(resData));
              } else {
                var clothes = data;
                var itemList = [];
                var isExist = [[]];
                for(var i=0; i<clothes.length; i++){
                  if(isExist[0][clothes[i].cloth_type] == undefined){
                    isExist[0][clothes[i].cloth_type] = [];
                  }
                  isExist[0][clothes[i].cloth_type][clothes[i].cloth_num] = true;
                }
                for(var i=0; i<items.length; i++){
                  if(isExist[items[i].table_num][items[i].type] == undefined || isExist[items[i].table_num][items[i].type][items[i].num] == undefined){
                    itemList.push(items[i]);
                  }
                }

                // for (var i=0; i<clothes.length; i++) {
                //   for (var j=items.length-1; j>=0; j--) {
                //     if (clothes[i].cloth_type == items[j].type && clothes[i].cloth_num == items[j].num) {
                //       items.splice(j, 1);
                //       break;
                //     }
                //   }
                // }
                if(itemList.length == 0){
                  resData['result'] = 'full_item';
                  socket.emit('randomCloth', AESCrypt.socketEncrypt(resData));
                  return;
                }else if(itemList.length < decData.itemNum){
                  resData['result'] = 'less_item';
                  socket.emit('randomCloth', AESCrypt.socketEncrypt(resData));
                  return;
                }

                var index;
                clothes = [];
                for(var i=0; i<decData.itemNum; i++){
                  index = Math.floor(Math.random() * itemList.length);
                  clothes.push({cloth_type:itemList[index].type, cloth_num:itemList[index].num});
                  itemList.splice(index, 1);
                }

                datasetup.addClothes(socket.name, clothes, function(err, data) {
                  if (err) {
                    resData['result'] = 'fail';
                    resData['error'] = err;
                    socket.emit('randomCloth', AESCrypt.socketEncrypt(resData));
                  } else {
                    resData['itemData'] = [];
                    for(var i=0; i<clothes.length; i++){
                      resData.itemData.push({type: clothes[i].cloth_type, num: clothes[i].cloth_num});
                    }

                    cash -= 500*decData.itemNum;
                    datasetup.setUserCash(socket.name, cash, function(err, data) {
                      if (err) {
                        resData['result'] = 'fail';
                        resData['error'] = err;
                      } else {
                        resData['result'] = 'success';
                        resData['cash'] = String(cash);
                      }
                      socket.emit('randomCloth', AESCrypt.socketEncrypt(resData));
                    });
                  }
                });
              }
            });
          }
        });
      } else {
        resData['result'] = 'not_enough_cash';
        socket.emit('randomCloth', AESCrypt.socketEncrypt(resData));
      }
    }
  });
});

socket.on('randomFurniture', function(data) {
  try {
    var decData = AESCrypt.socketDecrypt(data);
  } catch (error) {
    console.log('error:'+error);
    var rec = {'req': 'randomFurniture', 'reason': 'Invalid data', 'error': error, 'nickname': socket.name};
    datasetup.securityRecord(rec);

    socket.emit('wrong', AESCrypt.socketEncrypt(rec));
    socket.disconnect();
    return;
  }

  if (socket.name == undefined) {
    var rec = {'req': 'randomFurniture', 'reason': 'not_logined', 'data':decData};
    datasetup.securityRecord(rec);

    socket.emit('wrong', AESCrypt.socketEncrypt(rec));
    socket.disconnect();
    return;
  }

  if(decData.itemNum == undefined || decData.itemNum < 1 || decData.itemNum > 5){
    var rec = {'req': 'randomFurniture', 'reason': 'Invalid itemNum data', data:decData, nickname:socket.name};
    datasetup.securityRecord(rec);

    socket.emit('wrong', AESCrypt.socketEncrypt(rec));
    socket.disconnect();
    return;
  }

  datasetup.getUserFromNick(socket.name, function(err, data) {
    var resData = {};
    if (err) {
      resData['result'] = 'fail';
      resData['error'] = err;
      socket.emit('randomFurniture', AESCrypt.socketEncrypt(resData));
    } else {
      var cash = data[0].cash;
      if (cash >= 500*decData.itemNum) {
        datasetup.getItems(false, function(err, data) {
          if (err) {
            resData['result'] = 'fail';
            resData['error'] = err;
            socket.emit('randomFurniture', AESCrypt.socketEncrypt(resData));
          } else {
            var items = data;
            datasetup.getFurnitures(socket.name, function(err, data) {
              if (err) {
                resData['result'] = 'fail';
                resData['error'] = err;
                socket.emit('randomFurniture', AESCrypt.socketEncrypt(resData));
              } else {
                var furnitures = data;
                var itemList = [];
                var isExist = [undefined,[],[]];
                for(var i=0; i<furnitures.floorNwall.length; i++){
                  if(isExist[1][furnitures.floorNwall[i].furniture_type] == undefined){
                    isExist[1][furnitures.floorNwall[i].furniture_type] = [];
                  }
                  isExist[1][furnitures.floorNwall[i].furniture_type][furnitures.floorNwall[i].furniture_num] = true;
                }
                for(var i=0; i<furnitures.house.length; i++){
                  if(isExist[2][furnitures.house[i].furniture_type] == undefined){
                    isExist[2][furnitures.house[i].furniture_type] = [];
                  }
                  isExist[2][furnitures.house[i].furniture_type][furnitures.house[i].furniture_num] = true;
                }
                for(var i=0; i<items.length; i++){
                  if(isExist[items[i].table_num][items[i].type] == undefined || isExist[items[i].table_num][items[i].type][items[i].num] == undefined){
                    itemList.push(items[i]);
                  }
                }
                
                if(itemList.length == 0){
                  resData['result'] = 'full_item';
                  socket.emit('randomFurniture', AESCrypt.socketEncrypt(resData));
                  return;
                }else if(itemList.length < decData.itemNum){
                  resData['result'] = 'less_item';
                  socket.emit('randomFurniture', AESCrypt.socketEncrypt(resData));
                  return;
                }

                furnitures = [];
                var index;
                for(var i=0; i<decData.itemNum; i++){
                  index = Math.floor(Math.random() * itemList.length);
                  furnitures.push({table_num:itemList[index].table_num, furniture_type:itemList[index].type, furniture_num:itemList[index].num});
                  itemList.splice(index, 1);
                }
                
                datasetup.addFurnitures(socket.name, furnitures, function(err, data){
                  if(err){
                    resData['result'] = 'fail';
                    resData['error'] = err;
                    socket.emit('randomFurniture', AESCrypt.socketEncrypt(resData));
                  }else{
                    resData['itemData'] = [];
                    for(var i=0; i<furnitures.length; i++){
                      resData.itemData.push({
                        table_num:furnitures[i].table_num,
                        type:furnitures[i].furniture_type,
                        num:furnitures[i].furniture_num
                      });
                    }

                    cash -= 500*decData.itemNum;
                    datasetup.setUserCash(socket.name, cash, function(err, data) {
                      if (err) {
                        resData['result'] = 'fail';
                        resData['error'] = err;
                      } else {
                        resData['result'] = 'success';
                        resData['cash'] = String(cash);
                      }
                      socket.emit('randomFurniture', AESCrypt.socketEncrypt(resData));
                    });
                  }
                });
              }
            });
          }
        });
      } else {
        resData['result'] = 'not_enough_cash';
        socket.emit('randomFurniture', AESCrypt.socketEncrypt(resData));
      }
    }
  });
});

socket.on('setProfile', function(data) {
  try {
    var decData = AESCrypt.socketDecrypt(data);
  } catch (error) {
    console.log('error:'+error);
    var rec = {'req': 'setCash', 'reason': 'Invalid data', 'error': error, 'nickname': socket.name};
    datasetup.securityRecord(rec);

    socket.emit('wrong', AESCrypt.socketEncrypt(rec));
    socket.disconnect();
    return;
  }

  if (socket.name == undefined) {
    var rec = {'req': 'setProfile', 'reason': 'not_logined', 'data': decData};
    datasetup.securityRecord(rec);

    socket.emit('wrong', AESCrypt.socketEncrypt(rec));
    socket.disconnect();
    return;
  }

  if (decData.profile == undefined || decData.profile.length > 50) {
    var rec = {'req': 'setProfile', 'reason': 'Invalid profile value', "data": decData, "nickname": socket.name};
    datasetup.securityRecord(rec);

    socket.emit('wrong', AESCrypt.socketEncrypt(rec));
    socket.disconnect();
    return;
  }

  datasetup.setUserProfile(socket.name, decData.profile, function(err, data) {
    if (err) {
      decData['result'] = 'fail';
      decData['error'] = err;
    } else {
      decData['result'] = 'success';
    }
    socket.emit('setProfile', AESCrypt.socketEncrypt(decData));
  });
});


socket.on('fashionshow', function(data) {
  try {
    var decData = AESCrypt.socketDecrypt(data);
  } catch (error) {
    console.log('error:'+error);
    var rec = {'req': 'fashionshow', 'reason': 'Invalid data', 'error': error, 'nickname': socket.name};
    datasetup.securityRecord(rec);

    socket.emit('wrong', AESCrypt.socketEncrypt(rec));
    socket.disconnect();
    return;
  }
  console.log('fashionshow '+JSON.stringify(decData));

  if (socket.name == undefined) {
    var rec = {'req': 'fashionshow', 'reason': 'not_logined', 'data': decData};
    datasetup.securityRecord(rec);

    socket.emit('wrong', AESCrypt.socketEncrypt(rec));
    socket.disconnect();
    return;
  }

  if (channelList[socket.room] == undefined) {
    var rec = {'req': 'fashionshow', 'reason': 'not in channel', "data": decData, nickname: socket.name};
    datasetup.securityRecord(rec);

    socket.emit('wrong', AESCrypt.socketEncrypt(rec));
    socket.disconnect();
    return;
  }

  if (channelList[socket.room].users[socket.name] == undefined) {
    var rec = {'req': 'fashionshow', 'reason': 'not included', 'data': decData, 'nickname': socket.name};
    datasetup.securityRecord(rec);

    socket.emit('wrong', AESCrypt.socketEncrypt(rec));
    socket.disconnect();
    return;
  }

  if (decData.type == 'enter') {
    if(channelList[socket.room].fashion.waitList.includes(socket.name)){
      return;
    }

    datasetup.getFashionDate(socket.name, function(err, data) {
      if (err) {
        decData['result'] = 'fail';
        decData['error'] = err;
      } else {
        var diff = moment.duration(new Date() -  Date.parse(data[0].fashion_date)).asMilliseconds();
        if(diff >= 300000){ //5minutes
          decData['result'] = 'success';
          socket.isAd = true;
        }else{
          decData['result'] = 'wait';
          decData['time'] = diff;
        }
      }
      socket.emit('fashionshow', AESCrypt.socketEncrypt(decData));
    });
  } else if (decData.type == 'ad_end') {
    //ASK
    delete socket.isAd;
    if(channelList[socket.room].fashion.waitList.includes(socket.name)){
      return;
    }

    channelList[socket.room].fashion.waitList.push(socket.name);
    let waitNum = channelList[socket.room].fashion.waitList.length;
    if (waitNum == 1) {
      //TODO database
      datasetup.getUserFromNick(socket.name, function(err, res) {
        var resData = {};
        if (err) {
          resData['result'] = 'fail';
          resData['error'] = err;
          socket.emit('fashionshow', AESCrypt.socketEncrypt(resData));
        } else {
          channelList[socket.room].users[socket.name].x = 120;
          channelList[socket.room].users[socket.name].y = -610;
          // for (var i=waitNum-1; i>0; i--){
          //   let user = channelList[socket.room].fashion.waitList[i];
          //   if (channelList[socket.room].users[user] == undefined){
          //     channelList[socket.room].fashion.waitList.splice(i, 1);

          //     var toRoom = {};
          //     toRoom['nickname'] = user;
          //     toRoom['result'] = 'success';
          //     toRoom['type'] = 'cancel';
          //     io.to(socket.room).emit('fashionshow', AESCrypt.socketEncrypt(toRoom));
          //   } else {
          //     if (i < 10) {
          //       channelList[socket.room].users[user].x = 420 + i*90;
          //     } else {
          //       channelList[socket.room].users[user].x = 1320;
          //     }
          //     channelList[socket.room].users[user].y = -610;
          //   }
          // }

          resData['result'] = 'success';
          resData['type'] = 'start';
          resData['userData'] = res[0];
          io.to(socket.room).emit('fashionshow', AESCrypt.socketEncrypt(resData));
          channelList[socket.room].fashion.timer = setTimeout(fashionshow_end, 15000, res[0], socket.room);
        }
      });
    } else {
      if (waitNum-1 < 10) {
        channelList[socket.room].users[socket.name].x = 420 + (waitNum-1)*90;
      } else {
        channelList[socket.room].users[socket.name].x = 1320;
      }
      channelList[socket.room].users[socket.name].y = -610;
      
      var resData = {result: 'success', type: 'wait', nickname: socket.name, remain: channelList[socket.room].fashion.waitList.length-1};
      io.to(socket.room).emit('fashionshow', AESCrypt.socketEncrypt(resData));
    }
  } else if(decData.type == 'ad_skip'){
    delete socket.isAd;
  } else if (decData.type == 'score') {
    if (channelList[socket.room].fashion.timer == undefined) {
      // no fashionshow
    } else {
      if (channelList[socket.room].fashion.waitList[0] == decData.nickname) {
        if (decData.score == undefined || decData.score < 50 || decData.score > 100) {
          var rec = {'req': 'fashionshow', 'reason': 'Invalid score data', "data": decData, nickname: socket.name};
          datasetup.securityRecord(rec);

          socket.emit('wrong', AESCrypt.socketEncrypt(rec));
          socket.disconnect();
          return;
        }

        channelList[socket.room].fashion.scoreList[socket.name] = decData.score;
      } else {
        // not equal nickname
      }
    }
  } else if (decData.type == 'cancel') {
    var index = channelList[socket.room].fashion.waitList.indexOf(socket.name);
    if (index < 0) {
      var rec = {'req': 'fashionshow', 'reason': 'not in waitList', "data": decData, nickname: socket.name};
      datasetup.securityRecord(rec);

      socket.emit('wrong', AESCrypt.socketEncrypt(rec));
      socket.disconnect();
      return;
    } else {
      channelList[socket.room].fashion.waitList.splice(index, 1);
      if(channelList[socket.room].fashion.timer != undefined) {
        let userData = channelList[socket.room].fashion.timer._timerArgs[0];
        if (userData.nickname == socket.name) {
          // current in fashion show
          let roomId = channelList[socket.room].fashion.timer._timerArgs[1];
          clearTimeout(channelList[socket.room].fashion.timer);
          
          var next = undefined;
          if (channelList[roomId].fashion.waitList.length < 1) {
            delete channelList[roomId].fashion.timer;
          } else {
            while(channelList[roomId].fashion.waitList.length > 0){
              next = channelList[roomId].fashion.waitList[0];
              if (userList[next] == undefined || channelList[roomId].users[next] == undefined) {
                channelList[roomId].fashion.waitList.splice(0, 1);
              } else {
                break;
              }
            }
          }

          if (next == undefined || channelList[roomId].users[next] == undefined) {
            var toRoom = {result: 'success', type: 'end', user: userData.nickname};
            io.to(roomId).emit('fashionshow', AESCrypt.socketEncrypt(toRoom));

          } else {
            //TODO database
            datasetup.getUserFromNick(next, function(err, res) {
              var resData = {};
              if (err) {
                resData['result'] = 'fail';
                resData['error'] = err;
                userList[next].emit('fashionshow', AESCrypt.socketEncrypt(resData));
              } else {
                channelList[roomId].users[next].x = 120;
                channelList[roomId].users[next].y = -610;

                let waitNum = channelList[roomId].fashion.waitList.length;
                for (var i=waitNum-1; i>0; i--){
                  var user = channelList[roomId].fashion.waitList[i];
                  if (channelList[roomId].users[user] == undefined){
                    channelList[roomId].fashion.waitList.splice(i, 1);

                    var toRoom = {};
                    toRoom['nickname'] = user;
                    toRoom['result'] = 'success';
                    toRoom['type'] = 'cancel';
                    io.to(socket.room).emit('fashionshow', AESCrypt.socketEncrypt(toRoom));
                  } else {
                    if (i < 10) {
                      channelList[roomId].users[user].x = 420 + i*90;
                    } else {
                      channelList[roomId].users[user].x = 1320;
                    }
                    channelList[roomId].users[user].y = -610;
                  }
                }
                
                resData['result'] = 'success';
                resData['type'] = 'start';
                resData['userData'] = res[0];
                resData['user'] = userData.nickname;
                io.to(roomId).emit('fashionshow', AESCrypt.socketEncrypt(resData));
                channelList[roomId].fashion.timer = setTimeout(fashionshow_end, 15000, res[0], roomId);
              }
            });
          }
        }else{
          let waitNum = channelList[socket.room].fashion.waitList.length;
          for (var i=waitNum-1; i>=index; i--){
            let user = channelList[socket.room].fashion.waitList[i];
            if (channelList[socket.room].users[user] == undefined){
              channelList[socket.room].fashion.waitList.splice(i, 1);
    
              var toRoom = {};
              toRoom['nickname'] = user;
              toRoom['result'] = 'success';
              toRoom['type'] = 'cancel';
              io.to(socket.room).emit('fashionshow', AESCrypt.socketEncrypt(toRoom));
            } else {
              if (i < 10) {
                channelList[socket.room].users[user].x = 420 + i*90;
              } else {
                channelList[socket.room].users[user].x = 1320;
              }
              channelList[socket.room].users[user].y = -610;
            }
          }
        }
      }
    }

    if (decData.pos_x == undefined || decData.pos_x < -1200 || decData.pos_x > 1200
      || decData.pos_y == undefined || decData.pos_y < -746.25 || decData.pos_y > 716.25) {
        var rec = {'req': 'fashionshow', 'reason': 'Invalid position value', 'data': decData, 'nickname': socket.name};
        datasetup.securityRecord(rec);

        socket.emit('wrong', AESCrypt.socketEncrypt(rec));
        socket.disconnect();
        return;
      }
      
    if (decData.pos_x < -677.505 && decData.pos_y > 619.351
      || (decData.pos_x > 373.65 && decData.pos_y > 690.6)){ //&& !(decData.pos_x < 700.1464 && decData.pos_y < 1351.9114 - decData.pos_x))
        var rec = {'req': 'fashionshow', 'reason': 'Invalid position value', 'data': decData, 'nickname': socket.name};
        datasetup.securityRecord(rec);
  
        socket.emit('wrong', AESCrypt.socketEncrypt(rec));
        socket.disconnect();
        return;
    }

    channelList[socket.room].users[socket.name].x = decData.pos_x;
    channelList[socket.room].users[socket.name].y = decData.pos_y;

    decData['nickname'] = socket.name;
    decData['result'] = 'success';
    decData['type'] = 'cancel';
    io.to(socket.room).emit('fashionshow', AESCrypt.socketEncrypt(decData));
  } else {
    var rec = {'req': 'fashionshow', 'reason': 'Invalid type', "data": decData, nickname: socket.name};
    datasetup.securityRecord(rec);

    socket.emit('wrong', AESCrypt.socketEncrypt(rec));
    socket.disconnect();
    return;
  }
});

function fashionshow_end(userData, roomId) {
  if (channelList[roomId] == undefined) {
    return;
  }
  if (userList[userData.nickname] != undefined) {
    var scoreValue = 0;
    let rateList = Object.keys(channelList[roomId].fashion.scoreList);
    var scoreLength = rateList.length;
    if (scoreLength > 0) {
      for (var i=0; i<scoreLength; i++) {
        scoreValue += channelList[roomId].fashion.scoreList[rateList[i]];
        datasetup.addUserCash(rateList[i], 5);
      }
      scoreValue /= scoreLength;
      channelList[roomId].fashion.scoreList = {};
    } else {
      scoreValue = Math.floor(Math.random()*21) + 80;
    }

    //TODO database
    // datasetup.setUserCash(userData.nickname, userData.cash + scoreValue, function(err, data) {
    //   var resData = {nickname:userData.nickname, type: 'score', scoreNum: scoreLength, score: scoreValue};
    //   if (err) {
    //     resData['result'] = 'fail';
    //     resData['error'] = err;
    //     userList[userData.nickname].emit('fashionshow', AESCrypt.socketEncrypt(resData));
    //   } else {
    //     datasetup.updateFashionDate(userData.nickname, function(err, data) {
    //       if (err) {
    //         resData['result'] = 'fail';
    //         resData['error'] = err;
    //       } else {
    //         resData['result'] = 'success';
    //         resData['rateList'] = rateList;
    //       }
          
    //       io.to(roomId).emit('fashionshow', AESCrypt.socketEncrypt(resData));
    //     });
    //   }
    // });
    datasetup.addFastCash(userData.nickname, scoreValue*2, function(err, data) {
      var resData = {nickname:userData.nickname, type: 'score', scoreNum: scoreLength, score: scoreValue};
      if (err) {
        resData['result'] = 'fail';
        resData['error'] = err;
        userList[userData.nickname].emit('fashionshow', AESCrypt.socketEncrypt(resData));
      } else {
        datasetup.updateFashionDate(userData.nickname, function(err, data) {
          if (err) {
            resData['result'] = 'fail';
            resData['error'] = err;
          } else {
            resData['result'] = 'success';
            resData['rateList'] = rateList;
          }
          io.to(roomId).emit('fashionshow', AESCrypt.socketEncrypt(resData));
        });
      }
    });
  }

  channelList[roomId].fashion.waitList.splice(0, 1);
  var next = undefined;
  if (channelList[roomId].fashion.waitList.length < 1) {
    delete channelList[roomId].fashion.timer;
  } else {
    while(channelList[roomId].fashion.waitList.length > 0){
      next = channelList[roomId].fashion.waitList[0];
      if (userList[next] == undefined || channelList[roomId].users[next] == undefined) {
        next = undefined;
        channelList[roomId].fashion.waitList.splice(0, 1);
      } else {
        break;
      }
    }
  }

  if (next == undefined) {
    var toRoom = {result: 'success', type: 'end', user: userData.nickname};
    io.to(roomId).emit('fashionshow', AESCrypt.socketEncrypt(toRoom));

  } else {
    //TODO database
    datasetup.getUserFromNick(next, function(err, res) {
      var resData = {};
      if (err) {
        resData['result'] = 'fail';
        resData['error'] = err;
        userList[next].emit('fashionshow', AESCrypt.socketEncrypt(resData));
      } else {
        channelList[roomId].users[next].x = 120;
        channelList[roomId].users[next].y = -610;

        let waitNum = channelList[roomId].fashion.waitList.length;
        for (var i=waitNum-1; i>0; i--){
          let user = channelList[roomId].fashion.waitList[i];
          if (channelList[roomId].users[user] == undefined){
            channelList[roomId].fashion.waitList.splice(i, 1);

            var toRoom = {};
            toRoom['nickname'] = user;
            toRoom['result'] = 'success';
            toRoom['type'] = 'cancel';
            io.to(socket.room).emit('fashionshow', AESCrypt.socketEncrypt(toRoom));
          } else {
            if (i < 10) {
              channelList[roomId].users[user].x = 420 + i*90;
            } else {
              channelList[roomId].users[user].x = 1320;
            }
            channelList[roomId].users[user].y = -610;
          }
        }
        
        resData['result'] = 'success';
        resData['type'] = 'start';
        resData['userData'] = res[0];
        resData['user'] = userData.nickname;
        io.to(roomId).emit('fashionshow', AESCrypt.socketEncrypt(resData));
        channelList[roomId].fashion.timer = setTimeout(fashionshow_end, 15000, res[0], roomId);
      }
    });
  }
}

socket.on('dice', function(){
  if (socket.name == undefined) {
    var rec = {'req': 'dice', 'reason': 'not_logined'};
    datasetup.securityRecord(rec);

    socket.emit('wrong', AESCrypt.socketEncrypt(rec));
    socket.disconnect();
    return;
  }

  //send leave to room
  if(checkRoom('@dice')){
    return;
  }

  //except full room
  var roomId, newRoomId;
  var keyList = Object.keys(diceList);
  let keyLength = keyList.length;
  if(keyLength > 0){
    var last = keyList[keyList.length-1];
    last = last.slice(5, last.length);
    last = parseInt(last)+1;
    for (var i=last-1; i>=0; i--) {
      let key = '@dice'+i;
      let key_index = keyList.indexOf(key);
      if(diceList[key] == undefined && newRoomId == undefined){
        newRoomId = key;
      }else if (key_index >= 0 && Object.keys(diceList[key].locList).length >= 10) {
        keyList.splice(key_index,1);
      }
    }
  }

  //choose room id
  if(keyList.length == 0){
    if(newRoomId == undefined){
      roomId = '@dice'+keyLength;
    }else{
      roomId = newRoomId;
    }
  }else{
    roomId = keyList[Math.floor(Math.random()*keyList.length)];
  }
  
  var resData = {};
  if(diceList[roomId] == undefined){
    //make room
    diceList[roomId] = {};
    diceList[roomId]['locList'] = {};
    diceList[roomId]['snake'] = {};
    
    //make snakes
    var snakes_head_loc = [[],[],[]];
    let long_snake_loc = Math.floor(Math.random()*3);
    var head, tail, plus, isOverLong = 0;
    for (var i = 0; i < 3; i++) {
        do {
            head = Math.floor(Math.random()*4);
            tail = Math.floor(Math.random()*4);
        } while (i != 0 && tail == snakes_head_loc[i - 1][0]);
        snakes_head_loc[i][0] = head;
        snakes_head_loc[i][1] = tail;

        if(i == long_snake_loc){
          plus = 2;
        }else{
          plus = 1;
          if(i > long_snake_loc){
            isOverLong = 1;
          }
        }

        diceList[roomId].snake[tail + (i+isOverLong)*7+1] = head + (i+plus+isOverLong)*7+1;
        // if(Math.floor(Math.random()*2) == 1){
          
        // }else{
        //   diceList[roomId].snake[tail + (i+plus+isOverLong)*7+1] = head + (i+isOverLong)*7+1;
        // }
    }

    //start timer
    diceList[roomId].timer = setInterval(dice_end, 15000, roomId);
    diceList[roomId].timer._now = Date.now();
    
    resData['leftTime'] = 15;
    resData['locList'] = {};
    resData['snake'] = diceList[roomId].snake;
    resData['result'] = 'start';
    resData['room'] = roomId;
    socket.emit('dice', AESCrypt.socketEncrypt(resData));

    diceList[roomId].locList[socket.name] = 0;
    socket.room = roomId;
    socket.join(roomId);
    
  }else{
    resData['leftTime'] = getTimeLeft(diceList[roomId].timer);
    resData['locList'] = diceList[roomId].locList;
    resData['snake'] = diceList[roomId].snake;

    var nicknames = Object.keys(diceList[roomId].locList);
    var toRoom = {};
    //TODO database
    datasetup.getUserFromNick(socket.name, function(err, data){
      if(err){
        resData['result'] = 'fail';
        resData['error'] = err;
        socket.emit('dice', AESCrypt.socketEncrypt(resData));
      }else{
        toRoom['result'] = 'enter';
        toRoom['userData'] = data[0];

        datasetup.getUsersFromNick(nicknames, function(err, data){
          if(err){
            resData['result'] = 'fail';
            resData['error'] = err;
          }else{
            io.to(roomId).emit('dice', AESCrypt.socketEncrypt(toRoom));

            resData['result'] = 'start';
            resData['room'] = roomId;
            resData['userDatas'] = data;
            
            diceList[roomId].locList[socket.name] = 0;
            socket.room = roomId;
            socket.join(roomId);
          }
          socket.emit('dice', AESCrypt.socketEncrypt(resData));
        });
      }
    });
  }
});

function dice_end(roomId){
  console.log(roomId);
  if(diceList[roomId] == undefined){
    return;
  }

  var resData = {result: 'turn_end', leftTime: 15, diceData: {}};
  let nicknames = Object.keys(diceList[roomId].locList);
  for(var i=0; i<nicknames.length; i++){
    var dice = Math.floor(Math.random()*6)+1;
    var loc = diceList[roomId].locList[nicknames[i]];
    loc += dice;
    if(loc > 33){
      loc = 33;
    }
    if(diceList[roomId].snake[loc] != undefined){
      loc = diceList[roomId].snake[loc];
    }
    resData.diceData[nicknames[i]] = [dice,loc];
    diceList[roomId].locList[nicknames[i]] = loc;
  }
  
  io.to(roomId).emit('dice', AESCrypt.socketEncrypt(resData));

  for(var i=0; i<nicknames.length; i++){
    if(diceList[roomId].locList[nicknames[i]] == 33){
      delete diceList[roomId].locList[nicknames[i]];
      if (Object.keys(diceList[roomId].locList).length == 0) {
        clearInterval(diceList[roomId].timer);
        delete diceList[roomId];
      }

      if(userList[nicknames[i]] == undefined){
        var rec = {'req': 'dice', 'reason': 'no user', nickname: nicknames[i]};
        datasetup.securityRecord(rec);
        continue;

      }else if(userList[nicknames[i]].room != roomId){
        var rec = {'req': 'dice', 'reason': 'different room', nickname: nicknames[i]};
        datasetup.securityRecord(rec);
        continue;
      }
      let nickname = nicknames[i];
      userList[nickname].leave(roomId);
      delete userList[nickname].room;

      //TODO database
      datasetup.addUserCash(nickname, 50, function(err, data){
        var toUser = {};
        if(err){
          toUser['result'] = 'fail';
          toUser['error'] = err;
        }else{
          toUser['result'] = 'end';
          toUser['score'] = 50;
        }
        userList[nickname].emit('dice', AESCrypt.socketEncrypt(toUser));
      });
    }
  }

  if(diceList[roomId] != undefined){
    diceList[roomId].timer._now = Date.now();
  }
}

function getTimeLeft(timer) {
  var left = Math.ceil((timer._now+timer._idleTimeout - Date.now()) / 1000);
  return left;
}

socket.on('blinddate', function(){
  if(socket.name == undefined){
    var rec = {'req': 'blinddate', 'reason': 'not_logined'};
    datasetup.securityRecord(rec);

    socket.emit('wrong', AESCrypt.socketEncrypt(rec));
    socket.disconnect();
    return;
  }

  if(checkRoom('@blinddate')){
    return;
  }

  //find room
  var roomId, newRoomId;
  var keyList = Object.keys(blinddateList);
  if(keyList.length > 0){
    var last = keyList[keyList.length-1];
    last = last.slice(10, last.length);
    last = parseInt(last)+1;
    for (var i=0; i<last; i++) {
      let key = '@blinddate'+i;
      if(blinddateList[key] == undefined && newRoomId == undefined){
        newRoomId = key;
      }else if (keyList.includes(key) && blinddateList[key].userList.length < 2) {
        roomId = key;
        break;
      }
    }
  }

  if(roomId == undefined){
    if(newRoomId == undefined){
      roomId = '@blinddate'+keyList.length;
    }else{
      roomId = newRoomId;
    }
  }

  var resData = {};
  if(blinddateList[roomId] == undefined){
    blinddateList[roomId] = {};
    blinddateList[roomId]['userList'] = [];

    resData['result'] = 'success';
    resData['room'] = roomId;
    socket.emit('blinddate', AESCrypt.socketEncrypt(resData));

    blinddateList[roomId].userList.push(socket.name);
    socket.room = roomId;
    socket.join(roomId);
  }else{
    var toRoom = {};
    let nickname = blinddateList[roomId].userList[0];
    if(userList[nickname] == undefined){
      var rec = {'req': 'blinddate', 'reason': 'no user', 'nickname':socket.name};
      datasetup.securityRecord(rec);

      socket.emit('wrong', AESCrypt.socketEncrypt(rec));
      socket.disconnect();
      return;
    }

    //TODO database
    datasetup.getUserFromNick(socket.name, function(err, data){
      if(err){
        resData['result'] = 'fail';
        resData['error'] = err;
        socket.emit('blinddate', AESCrypt.socketEncrypt(resData));
      }else{
        toRoom['result'] = 'success';
        toRoom['userData'] = data[0];

        datasetup.getUserFromNick(nickname, function(err, data){
          if(err){
            resData['result'] = 'fail'
            resData['error'] = err;
          }else{
            userList[nickname].emit('blinddate', AESCrypt.socketEncrypt(toRoom));

            resData['result'] = 'success';
            resData['room'] = roomId;
            resData['userData'] = data[0];

            blinddateList[roomId].userList.push(socket.name);
            socket.room = roomId;
            socket.join(roomId);
          }
          socket.emit('blinddate', AESCrypt.socketEncrypt(resData));
        });
      }
    });
  }
});

socket.on('foothold', function(){
  if(socket.name == undefined){
    var rec = {'req': 'foothold', 'reason': 'not_logined'};
    datasetup.securityRecord(rec);

    socket.emit('wrong', AESCrypt.socketEncrypt(rec));
    socket.disconnect();
    return;
  }

  if(checkRoom('@foothold')){
    return;
  }

  //find room
  var roomId, newRoomId;
  var keyList = Object.keys(footholdList);
  keyList.splice(0,1);
  var last = 0;
  if(keyList.length > 0){
    last = keyList[keyList.length-1];
    last = last.slice(9, last.length);
    last = parseInt(last)+1;
    
    for (var i=0; i<last; i++) {
      let key = '@foothold'+i;
      if(footholdList[key] == undefined && newRoomId == undefined){
        newRoomId = key;
      }else if (keyList.includes(key) && footholdList[key].timer.isWait) {
        roomId = key;
        break;
      }
    }
  }

  if(roomId == undefined){
    if(newRoomId == undefined){
      roomId = '@foothold'+last;
    }else{
      roomId = newRoomId;
    }
  }

  var resData = {};
  if(footholdList[roomId] == undefined){
    footholdList[roomId] = {};
    footholdList[roomId]['userList'] = {};
    footholdList[roomId]['indexList'] = [undefined, undefined, undefined, undefined, undefined];
    footholdList[roomId]['timer'] = setTimeout(foothold_start, 15000, roomId);
    footholdList[roomId].timer.isWait = true;
    footholdList[roomId].timer._now = Date.now();

    footholdList[roomId].indexList[0] = socket.name;
    footholdList[roomId].userList[socket.name] = {x:footholdList.waitLoc[0],y:0};
    socket.room = roomId;
    socket.join(roomId);

    resData['result'] = 'enter';
    resData['room'] = roomId;
    resData['leftTime'] = 15;
    resData['pos_x'] = footholdList.waitLoc[0];
    resData['pos_y'] = 0;
    socket.emit('foothold', AESCrypt.socketEncrypt(resData));

  }else{
    var toRoom = {};
    let nicknames = Object.keys(footholdList[roomId].userList);
    //TODO database
    datasetup.getUserFromNick(socket.name, function(err, data){
      if(err){
        resData['result'] = 'fail';
        resData['error'] = err;
        socket.emit('foothold', AESCrypt.socketEncrypt(resData));
      }else{
        toRoom['result'] = 'enter';
        toRoom['userData'] = data[0];

        datasetup.getUsersFromNick(nicknames, function(err, data){
          if(err){
            resData['result'] = 'fail'
            resData['error'] = err;
            socket.emit('foothold', AESCrypt.socketEncrypt(resData));
          }else{
            // set location
            var index;
            for(var i=0; i<footholdList[roomId].indexList.length; i++){
              if(footholdList[roomId].indexList[i] == undefined){
                index = i;
                footholdList[roomId].indexList[i] = socket.name;
                break;
              }
            }
            footholdList[roomId].userList[socket.name] = {x:footholdList.waitLoc[index],y:0};

            toRoom.userData['x'] = footholdList.waitLoc[index];
            toRoom.userData['y'] = 0;
            io.to(roomId).emit('foothold', AESCrypt.socketEncrypt(toRoom));

            resData['result'] = 'enter';
            resData['room'] = roomId;
            resData['leftTime'] = getTimeLeft(footholdList[roomId].timer);
            resData['pos_x'] = footholdList.waitLoc[index];
            resData['pos_y'] = 0;
            for (var j=0; j<data.length; j++) {
              data[j]['x'] = footholdList[roomId].userList[data[j].nickname].x;
              data[j]['y'] = footholdList[roomId].userList[data[j].nickname].y;
            }
            resData['userDatas'] = data;
            socket.emit('foothold', AESCrypt.socketEncrypt(resData));

            socket.room = roomId;
            socket.join(roomId);

            // start if room is full
            if(data.length == 4){
              clearTimeout(footholdList[roomId].timer);
              footholdList[roomId].timer = setTimeout(foothold_end, 15000, roomId);
              io.to(roomId).emit('foothold', AESCrypt.socketEncrypt({result:'start', leftTime:15}));
            }
          }
        });
      }
    });
  }

  function foothold_start(roomId){
    console.log(roomId+' start');
    if(footholdList[roomId] == undefined){
      return;
    }
    footholdList[roomId].timer = setTimeout(foothold_end, 15000, roomId);
    io.to(roomId).emit('foothold', AESCrypt.socketEncrypt({result:'start', leftTime:15}));
  }

  function foothold_end(roomId){
    console.log(roomId+' end');
    if(footholdList[roomId] == undefined){
      return;
    }
    
    var footholds = {};
    let nicknames = Object.keys(footholdList[roomId].userList);
    for(var i=0; i<nicknames.length; i++){
      let pos_x = footholdList[roomId].userList[nicknames[i]].x;
      let pos_y = footholdList[roomId].userList[nicknames[i]].y;
      if(pos_x > 0){
        if(pos_y > 53){
          footholds[nicknames[i]] = 1;
          continue;
        }
        if(pos_y < -53){
          footholds[nicknames[i]] = 3;
          continue;
        }
      }else{
        if(pos_y > 53){
          footholds[nicknames[i]] = 0;
          continue;
        }
        if(pos_y < -53){
          footholds[nicknames[i]] = 2;
          continue;
        }
      }
    }
    
    var foothold = Math.floor(Math.random()*4);
    var resData = {result:'end', 'foothold':foothold, score:150};
    for(var i=0; i<nicknames.length; i++){
      if(footholds[nicknames[i]] == foothold){
        datasetup.addUserCash(nicknames[i], 150);
      }
    }
    io.to(roomId).emit('foothold', AESCrypt.socketEncrypt(resData));

    //leave and delete room
    for(var i=0; i<nicknames.length; i++){
      if(userList[nicknames[i]] == undefined){
        var rec = {'req': 'foothold', 'reason': 'no user', "nickname": nicknames[i]};
        datasetup.securityRecord(rec);
        continue;
      }

      userList[nicknames[i]].leave(roomId);
      delete userList[nicknames[i]].room;
    }
    delete footholdList[roomId];
  }
});

socket.on('androidInapp', function(data){
  if(socket.name == undefined){
    var rec = {'req': 'androidInapp', 'reason': 'not_logined'};
    datasetup.securityRecord(rec);

    socket.emit('wrong', AESCrypt.socketEncrypt(rec));
    socket.disconnect();
    return;
  }
  if(data.receipt == undefined){
    var rec = {'req': 'androidInapp', 'reason': 'undefined receipt data', 'nickname':socket.name};
    datasetup.securityRecord(rec);
    socket.emit('wrong', AESCrypt.socketEncrypt(rec));

    socket.disconnect();
    return;
  }
  try {
    data.receipt = AESCrypt.decrypt(data.receipt);
    var receipt = JSON.parse(data.receipt);
    receipt.Payload = JSON.parse(receipt.Payload);
  } catch (error) {
    console.log('error:'+error);
    var rec = {'req': 'androidInapp', 'reason': 'Invalid data', 'error': error, 'nickname':socket.name};
    datasetup.securityRecord(rec);
    socket.emit('wrong', AESCrypt.socketEncrypt(rec));

    socket.disconnect();
    return;
  }
  
  var resData = {};
  datasetup.getReceipt(receipt.TransactionID, function(err, res){
    if(err){
      resData['result'] = 'fail';
      resData['error'] = err;
      
      socket.emit('androidInapp', AESCrypt.socketEncrypt(resData));
    }else{
      if(res.length == 0){
        iap.validate(receipt, 
          function (err, androidRes) {
            resData['productId'] = androidRes.productId;
              //   
              if (err) {
                console.log('android validate err');
                resData['result'] = 'fail';
                resData['error'] = err;
                socket.emit('androidInapp', AESCrypt.socketEncrypt(resData));
                return;
              }else if(androidRes.packageName != 'com.familsoft.fortunecloset'){
                var rec = {'req': 'androidInapp', 'reason': 'diff_package', 'data':receipt, 'nickname':socket.name};
                datasetup.securityRecord(rec);
                resData['result'] = 'diff_package';
                socket.emit('androidInapp', AESCrypt.socketEncrypt(resData));
                return;
              }

              // 
              if (iap.isValidated(androidRes)) {
                //TODO database
                datasetup.addUserCash(socket.name, datasetup.protocol.cashamount[androidRes.productId], function(err, cash){
                  if(err){
                    resData['result'] = 'fail';
                    resData['error'] = err;
                  }else{
                    datasetup.addReceipt(socket.name, receipt.TransactionID, androidRes, datasetup.protocol.login_method.ios);
                    resData['result'] = 'success';
                    resData['cash'] = String(cash);
                  }
                  socket.emit('androidInapp', AESCrypt.socketEncrypt(resData));
                });
                
              } else {
                resData['result'] = 'not_validated';
                socket.emit('androidInapp', AESCrypt.socketEncrypt(resData));
              }
          });
      }else{
        var rec = {'req': 'androidInapp', 'reason': 'duple_receipt', 'data':receipt, 'nickname':socket.name};
        datasetup.securityRecord(rec);
        resData['result'] = 'duple';
        socket.emit('androidInapp', AESCrypt.socketEncrypt(resData));
      }
    }
  });
});

socket.on('iosInapp', function(data){
  try {
    var decData = AESCrypt.socketDecrypt(data);
  } catch (error) {
    console.log('error:'+error);
    var rec = {'req': 'iosInapp', 'reason': 'Invalid data', 'error': error, 'nickname':socket.name};
    datasetup.securityRecord(rec);
    socket.emit('wrong', AESCrypt.socketEncrypt(rec));

    socket.disconnect();
    return;
  }
  if(socket.name == undefined){
    var rec = {'req': 'iosInapp', 'reason': 'not_logined'};
    datasetup.securityRecord(rec);

    socket.emit('wrong', AESCrypt.socketEncrypt(rec));
    socket.disconnect();
    return;
  }
  if(decData.receipt == undefined){
    var rec = {'req': 'iosInapp', 'reason': 'undefined receipt data', 'data':decData, 'nickname':socket.name};
    datasetup.securityRecord(rec);
    socket.emit('wrong', AESCrypt.socketEncrypt(rec));

    socket.disconnect();
    return;
  }

  var resData = {};
  datasetup.getReceipt(decData.receipt.TransactionID, function(err, data){
    if(err){
      resData['result'] = 'fail';
      resData['error'] = err;
      
      socket.emit('iosInapp', AESCrypt.socketEncrypt(resData));
    }else{
      if(data.length == 0){
        iap.validate(
          iap.APPLE, 
          decData.receipt.Payload, 
          function (err, appleRes) {
              //   
              if (err) {
                console.log('ios validate err');
                resData['result'] = 'fail';
                resData['error'] = err;
                socket.emit('iosInapp', AESCrypt.socketEncrypt(resData));
                return;
              }else if(appleRes.receipt.bundle_id != 'com.familsoft.fortunecloset'){
                var rec = {'req': 'iosInapp', 'reason': 'diff_package', 'data':decData, 'nickname':socket.name};
                datasetup.securityRecord(rec);
                resData['result'] = 'diff_package';
                socket.emit('iosInapp', AESCrypt.socketEncrypt(resData));
                return;
              }

              // 
              if (iap.isValidated(appleRes)) {
                var purchaseDataList = iap.getPurchaseData(appleRes);
                var matchReceipt;
                for(var i=0; i<purchaseDataList.length; i++){
                  if(purchaseDataList[i].transactionId == decData.receipt.TransactionID){
                    matchReceipt = purchaseDataList[i];
                    break;
                  }
                }
                if(matchReceipt == undefined){
                  resData['result'] = 'fail';
                  resData['error'] = {error:'no match receipt'};
                  socket.emit('iosInapp', AESCrypt.socketEncrypt(resData));
                }

                resData['productId'] = matchReceipt.productId;
                //TODO database
                datasetup.addUserCash(socket.name, datasetup.protocol.cashamount[matchReceipt.productId], function(err, cash){
                  if(err){
                    resData['result'] = 'fail';
                    resData['error'] = err;
                  }else{
                    datasetup.addReceipt(socket.name, decData.receipt.TransactionID, matchReceipt, datasetup.protocol.login_method.ios);
                    resData['result'] = 'success';
                    resData['cash'] = String(cash);
                  }
                  socket.emit('iosInapp', AESCrypt.socketEncrypt(resData));
                });
                
              } else {
                resData['result'] = 'not_validated';
                socket.emit('iosInapp', AESCrypt.socketEncrypt(resData));
              }
          });
      }else{
        var rec = {'req': 'iosInapp', 'reason': 'duple_receipt', 'data':decData.receipt, 'nickname':socket.name};
        datasetup.securityRecord(rec);
        resData['result'] = 'duple';
        socket.emit('iosInapp', AESCrypt.socketEncrypt(resData));
      }
    }
  });
});

socket.on('idle', function(data){
  try {
    var decData = AESCrypt.socketDecrypt(data);
  } catch (error) {
    console.log('error:'+error);
    var rec = {'req': 'idle', 'reason': 'Invalid data', 'error': error, 'nickname':socket.name};
    datasetup.securityRecord(rec);
    socket.emit('wrong', AESCrypt.socketEncrypt(rec));

    socket.disconnect();
    return;
  }

  if(decData.idle){
    if(socket.idleTimer == undefined){
      socket.idleTimer = setTimeout(function(){
        socket.disconnect(true);
      }, 600000);
    }
  }else{
    if(socket.idleTimer){
      clearTimeout(socket.idleTimer);
      delete socket.idleTimer;
    }
  }
});

socket.on('flower', function(data){
  try {
    var decData = AESCrypt.socketDecrypt(data);
  } catch (error) {
    console.log('error:'+error);
    var rec = {'req': 'idle', 'reason': 'Invalid data', 'error': error, 'nickname':socket.name};
    datasetup.securityRecord(rec);
    socket.emit('wrong', AESCrypt.socketEncrypt(rec));

    socket.disconnect();
    return;
  }

  if(socket.name == undefined){
    var rec = {'req': 'flower', 'reason': 'not_logined', 'data': decData};
    datasetup.securityRecord(rec);

    socket.emit('wrong', AESCrypt.socketEncrypt(rec));
    socket.disconnect();
    return;
  }

  if(decData.num == undefined || !Number.isInteger(decData.num) || decData.num < 0 || decData.num >= datasetup.protocol.flower_value.length){
    var rec = {'req': 'flower', 'reason': 'Invalid flower num', data: decData, nickname: socket.name};
    datasetup.securityRecord(rec);

    socket.emit('wrong', AESCrypt.socketEncrypt(rec));
    socket.disconnect();
    return;
  }

  datasetup.getFlower(socket.name, decData.num, function(err, data){
    if(err){
      decData['result'] = 'fail';
      decData['error'] = err;
      socket.emit('flower', AESCrypt.socketEncrypt(decData));
    }else{
      if(data.length == 0){
        //TODO database
        datasetup.addFlower(socket.name, decData.num);
        datasetup.addUserCash(socket.name, datasetup.protocol.flower_value[decData.num], function(err, cash){
          if(err){
            decData['result'] = 'fail';
            decData['error'] = err;
          }else{
            decData['result'] = 'success';
            decData['cash'] = String(cash);
          }
          socket.emit('flower', AESCrypt.socketEncrypt(decData));
        });
      }else{
        let respawnTime = Date.parse(data[0].respawn_time);
        if(respawnTime - new Date() > 0){
          decData['result'] = 'notyet';
          decData['respawn_time'] = respawnTime;
          socket.emit('flower', AESCrypt.socketEncrypt(decData));
        }else{
          //TODO database
          datasetup.updateFlower(socket.name, decData.num);
          datasetup.addUserCash(socket.name, datasetup.protocol.flower_value[decData.num], function(err, cash){
            if(err){
              decData['result'] = 'fail';
              decData['error'] = err;
            }else{
              decData['result'] = 'success';
              decData['cash'] = String(cash);
            }
            socket.emit('flower', AESCrypt.socketEncrypt(decData));
          });
        }
      }
    }
  });
});

socket.on('slot', function(){
  if(socket.name == undefined){
    var rec = {'req': 'slot', 'reason': 'not_logined'};
    datasetup.securityRecord(rec);

    socket.emit('wrong', AESCrypt.socketEncrypt(rec));
    socket.disconnect();
    return;
  }

  if(checkRoom('@slot')){
    return;
  }

  //find room
  var roomId, newRoomId;
  var keyList = Object.keys(slotList);
  if(keyList.length > 0){
    var last = keyList[keyList.length-1];
    last = last.slice(5, last.length);
    last = parseInt(last)+1;
    
    for (var i=0; i<last; i++) {
      let key = '@slot'+i;
      if(slotList[key] == undefined && newRoomId == undefined){
        newRoomId = key;
      }else if (keyList.includes(key) && Object.keys(slotList[key]).length < 5) {
        roomId = key;
        break;
      }
    }
  }

  if(roomId == undefined){
    if(newRoomId == undefined){
      roomId = '@slot'+keyList.length;
    }else{
      roomId = newRoomId;
    }
  }
  
  var resData = {};
  if(slotList[roomId] == undefined){
    datasetup.getSlot(socket.name, function(err, data){
      if(err){
        resData['result'] = 'fail';
        resData['error'] = err;
      }else{
        slotList[roomId] = {};
        slotList[roomId][socket.name] = {x: 0, y: 0};

        resData['result'] = 'success';
        resData['room'] = roomId;
        resData['slotData'] = data;

        socket.join(roomId);
        socket.room = roomId;
      }
      socket.emit('slot', AESCrypt.socketEncrypt(resData));
    });
    
  }else{
    var toRoom = {};
    let nicknames = Object.keys(slotList[roomId]);
    //TODO database
    datasetup.getUserFromNick(socket.name, function(err, data){
      if(err){
        resData['result'] = 'fail';
        resData['error'] = err;
        socket.emit('slot', AESCrypt.socketEncrypt(resData));
      }else{
        toRoom['result'] = 'enter';
        toRoom['userData'] = data[0];

        datasetup.getUsersFromNick(nicknames, function(err, data){
          if(err){
            resData['result'] = 'fail'
            resData['error'] = err;
            socket.emit('slot', AESCrypt.socketEncrypt(resData));
          }else{
            for(var i=0; i<data.length; i++){
              data[i]['x'] = slotList[roomId][data[i].nickname].x;
              data[i]['y'] = slotList[roomId][data[i].nickname].y;
            }
            resData['userDatas'] = data;

            datasetup.getSlot(socket.name, function(err, data){
              if(err){
                resData['result'] = 'fail';
                resData['error'] = err;
              }else{
                io.to(roomId).emit('slot', AESCrypt.socketEncrypt(toRoom));

                slotList[roomId][socket.name] = {x: 0, y: 0};
        
                resData['result'] = 'success';
                resData['room'] = roomId;
                resData['slotData'] = data;
        
                socket.join(roomId);
                socket.room = roomId;
              }
              socket.emit('slot', AESCrypt.socketEncrypt(resData));
            });
          }
        });
      }
    });
  }
});

socket.on('addSlot', function(){
  if(socket.name == undefined){
    var rec = {'req': 'addSlot', 'reason': 'not_logined'};
    datasetup.securityRecord(rec);

    socket.emit('wrong', AESCrypt.socketEncrypt(rec));
    socket.disconnect();
    return;
  }

  var resData = {};
  datasetup.getSlot(socket.name, function(err,data){
    if(err){
      resData['result'] = 'fail';
      resData['error'] = err;
      socket.emit('addSlot', AESCrypt.socketEncrypt(resData));
    }else{
      var slotNum = data.length;
      if(slotNum > 5){
        return;
      }
      datasetup.getUserFromNick(socket.name, function(err, data){
        if(err){
          resData['result'] = 'fail';
          resData['error'] = err;
          socket.emit('addSlot', AESCrypt.socketEncrypt(resData));
        }else{
          let cash = data[0].cash;
          if(cash >= datasetup.protocol.slot_value[slotNum]){
            datasetup.addSlot(socket.name, slotNum, function(err, data){
              if(err){
                resData['result'] = 'fail';
                resData['error'] = err;
                socket.emit('addSlot', AESCrypt.socketEncrypt(resData));
              }else{
                cash -= datasetup.protocol.slot_value[slotNum];
                datasetup.setUserCash(socket.name, cash, function(err, data){
                  if(err){
                    resData['result'] = 'fail';
                    resData['error'] = err;
                  }else{
                    resData['result'] = 'success';
                    resData['slotNum'] = slotNum;
                    resData['hair'] = -1;
                    resData['face'] = 0;
                    resData['bottom'] = -1;
                    resData['shoes'] = -1;
                    resData['skin'] = 0;
                    resData['top'] = -1;
                    resData['hairac'] = -1;
                    resData['cash'] = String(cash);
                  }
                  socket.emit('addSlot', AESCrypt.socketEncrypt(resData));
                });
              }
            });
          }else{
            resData['result'] = 'not_enough_cash';
            socket.emit('addSlot', AESCrypt.socketEncrypt(resData));
          }
        }
      });
    }
  });
});

socket.on('getSlot', function(data){
  if(data != undefined){
    try {
      var decData = AESCrypt.socketDecrypt(data);
    } catch (error) {
      console.log('error:'+error);
      var rec = {'req': 'addSlot', 'reason': 'Invalid data', 'error': error, 'nickname':socket.name};
      datasetup.securityRecord(rec);
      socket.emit('wrong', AESCrypt.socketEncrypt(rec));
  
      socket.disconnect();
      return;
    }
  }

  if(socket.name == undefined){
    var rec = {'req': 'getSlot', 'reason': 'not_logined', 'data': decData};
    datasetup.securityRecord(rec);

    socket.emit('wrong', AESCrypt.socketEncrypt(rec));
    socket.disconnect();
    return;
  }
  
  var nick = socket.name;
  if(decData != undefined){
    if(decData.nickname == undefined || decData.nickname.length < 0 || decData.nickname.length > 12){
      var rec = {'req': 'getSlot', 'reason': 'Invalid nickname data', data: decData, nickname:socket.name};
      datasetup.securityRecord(rec);

      socket.emit('wrong', AESCrypt.socketEncrypt(rec));
      socket.disconnect();
      return;
    }
    nick = decData.nickname;
  }

  var resData = {};
  datasetup.getSlot(nick, function(err, data){
    if(err){
      resData['result'] = 'fail';
      resData['error'] = err;
    }else{
      resData['result'] = 'success';
      resData['nickname'] = nick;
      resData['slotData'] = data;
    }
    socket.emit('getSlot', AESCrypt.socketEncrypt(resData));
  });
});

socket.on('setSlot', function(data){
  try {
    var decData = AESCrypt.socketDecrypt(data);
  } catch (error) {
    console.log('error:'+error);
    var rec = {'req': 'setSlot', 'reason': 'Invalid data', 'error': error, 'nickname':socket.name};
    datasetup.securityRecord(rec);
    socket.emit('wrong', AESCrypt.socketEncrypt(rec));

    socket.disconnect();
    return;
  }

  if(socket.name == undefined){
    var rec = {'req': 'setSlot', 'reason': 'not_logined', 'data': decData};
    datasetup.securityRecord(rec);

    socket.emit('wrong', AESCrypt.socketEncrypt(rec));
    socket.disconnect();
    return;
  }

  if(decData.slotNum == undefined || decData.slotNum < 0 || decData.slotNum > 5){
    var rec = {'req': 'setSlot', 'reason': 'Invalid slotNum', data: decData, nickname: socket.name};
    datasetup.securityRecord(rec);

    socket.emit('wrong', AESCrypt.socketEncrypt(rec));
    socket.disconnect();
    return;
  }

  datasetup.checkSlot(socket.name, decData.slotNum, function(err, data){
    if(err){
      decData['result'] = 'fail';
      decData['error'] = err;
      socket.emit('setSlot', AESCrypt.socketEncrypt(decData));
    }else{
      if(data.length == 0){
        var rec = {'req': 'setSlot', 'reason': 'no slot', "nickname": socket.name, "data": decData};
        datasetup.securityRecord(rec);

        socket.emit('wrong', AESCrypt.socketEncrypt(rec));
        socket.disconnect();
        return;
      }else{
        datasetup.getUserFromNick(socket.name, function(err, data){
          if(err){
            decData['result'] = 'fail';
            decData['error'] = err;
            socket.emit('setSlot', AESCrypt.socketEncrypt(decData));
          }else{
            var resData = data[0];
            resData['slotNum'] = decData.slotNum;
            datasetup.setSlot(socket.name, resData, function(err, data){
              if(err){
                resData['result'] = 'fail';
                resData['error'] = err;
              }else{
                resData['result'] = 'success';
              }
              socket.emit('setSlot', AESCrypt.socketEncrypt(resData));
            });
          }
        });
      }
    }
  });
});

socket.on('fishing', function(data){
  try {
    var decData = AESCrypt.socketDecrypt(data);
  } catch (error) {
    console.log('error:'+error);
    var rec = {'req': 'fishing', 'reason': 'Invalid data', 'error': error, 'nickname':socket.name};
    datasetup.securityRecord(rec);
    socket.emit('wrong', AESCrypt.socketEncrypt(rec));

    socket.disconnect();
    return;
  }
  console.log('fishing '+JSON.stringify(decData));

  if(socket.name == undefined){
    var rec = {'req': 'fishing', 'reason': 'not_logined', 'data':decData};
    datasetup.securityRecord(rec);

    socket.emit('wrong', AESCrypt.socketEncrypt(rec));
    socket.disconnect();
    return;
  }

  if(decData.result == 'enter'){
    if(checkRoom('@fishing')){
      return;
    }
  
    //find room
    var roomId, newRoomId;
    var keyList = Object.keys(fishingList);
    keyList.splice(0,1);
    let keyLength = keyList.length;
    if(keyList.length > 0){
      var last = keyList[keyList.length-1];
      last = last.slice(8, last.length);
      last = parseInt(last)+1;
      
      for (var i=0; i<last; i++) {
        let key = '@fishing'+i;
        let key_index = keyList.indexOf(key);
        if(fishingList[key] == undefined && newRoomId == undefined){
          newRoomId = key;
        }else if (key_index >= 0 && Object.keys(fishingList[key]).length >= 10) {
          keyList.splice(key_index, 1);
        }
      }
    }
  
    //choose room id
    if(keyList.length == 0){
      if(newRoomId == undefined){
        roomId = '@fishing'+keyLength;
      }else{
        roomId = newRoomId;
      }
    }else{
      roomId = keyList[Math.floor(Math.random()*keyList.length)];
    }

    if(fishingList[roomId] == undefined){
      fishingList[roomId] = {};
      fishingList[roomId][socket.name] = {};
      fishingList[roomId][socket.name]['seatNum'] = 0;
      fishingList[roomId][socket.name]['timer'] = setTimeout(fishing_start, 10000+Math.random()*50000, roomId, socket.name);

      decData['room'] = roomId;
      decData['seatLoc'] = JSON.parse(JSON.stringify(fishingList.seatLoc[0]));
      socket.emit('fishing', AESCrypt.socketEncrypt(decData));

      socket.room = roomId;
      socket.join(roomId);
    }else{
      var nicknames = Object.keys(fishingList[roomId]);
      var toRoom = {};
      
      datasetup.getUserFromNick(socket.name, function(err, data){
        if(err){
          decData['result'] = 'fail';
          decData['error'] = err;
          socket.emit('fishing', AESCrypt.socketEncrypt(decData));
        }else{
          toRoom['result'] = 'enter';
          toRoom['userData'] = data[0];
          
          datasetup.getUsersFromNick(nicknames, function(err, data){
            if(err){
              decData['result'] = 'fail';
              decData['error'] = err;
            }else{
              var currentSeatNums =
              [undefined, undefined, undefined, undefined, undefined,
                undefined, undefined, undefined, undefined, undefined];
              for(var i=0; i<data.length; i++){
                let seatNum = fishingList[roomId][data[i].nickname].seatNum;
                data[i].x = fishingList.seatLoc[seatNum].x;
                data[i].y = fishingList.seatLoc[seatNum].y;

                currentSeatNums[seatNum] = true;
              }

              var newSeatNum;
              for(var i=0; i<currentSeatNums.length; i++){
                if(currentSeatNums[i] == undefined){
                  newSeatNum = i;
                  break;
                }
              }

              toRoom['userData'].x = fishingList.seatLoc[newSeatNum].x;
              toRoom['userData'].y = fishingList.seatLoc[newSeatNum].y;
              io.to(roomId).emit('fishing', AESCrypt.socketEncrypt(toRoom));

              decData['room'] = roomId;
              decData['seatLoc'] = JSON.parse(JSON.stringify(fishingList.seatLoc[newSeatNum]));
              decData['userDatas'] = data;
              
              fishingList[roomId][socket.name] = {};
              fishingList[roomId][socket.name]['seatNum'] = newSeatNum;
              fishingList[roomId][socket.name]['timer'] = setTimeout(fishing_start, 10000+Math.random()*50000, roomId, socket.name);

              socket.room = roomId;
              socket.join(roomId);
            }
            socket.emit('fishing', AESCrypt.socketEncrypt(decData));
          });
        }
      });
    }
  }else if(decData.result == 'catch'){
    if(fishingList[socket.room] == undefined){
      return;
    }else if(fishingList[socket.room][socket.name] == undefined){
      return;
    }

    if(fishingList[socket.room][socket.name].timer.fishing_state){
      decData['nickname'] = socket.name;
      decData['score'] = 1+Math.random()*20;

      datasetup.addUserCash(socket.name, decData.score, function(err, data){
        if(err){
          decData['result'] = 'fail';
          decData['error'] = err;
        }else{
          clearTimeout(fishingList[socket.room][socket.name].timer);
          fishingList[socket.room][socket.name].timer = setTimeout(fishing_start, 10000+Math.random()*50000, socket.room, socket.name);
     
        }
        io.to(socket.room).emit('fishing', AESCrypt.socketEncrypt(decData));
      });
    }

  }else if(decData.result == 'miss'){
    if(fishingList[socket.room] == undefined){
      return;
    }else if(fishingList[socket.room][socket.name] == undefined){
      return;
    }

    if(fishingList[socket.room][socket.name].timer.fishing_state){
      clearTimeout(fishingList[socket.room][socket.name].timer);
      fishingList[socket.room][socket.name].timer = setTimeout(fishing_start, 10000+Math.random()*50000, socket.room, socket.name);

      decData['nickname'] = socket.name;
      io.to(socket.room).emit('fishing', AESCrypt.socketEncrypt(decData));
    }
    
  }else{
    var rec = {'req': 'fishing', 'reason': 'Invalid type data', data:decData, nickname:socket.name};
    datasetup.securityRecord(rec);

    socket.emit('wrong', AESCrypt.socketEncrypt(rec));
    socket.disconnect();
    return;
  }

  function fishing_start(roomId, nickname){
    console.log('fishing start '+roomId+'/'+nickname);
    if(fishingList[roomId] == undefined){
      return;
    }else if(fishingList[roomId][nickname] == undefined){
      return;
    }
    
    fishingList[roomId][nickname].timer = setTimeout(fishing_end, 10000, roomId, nickname);
    fishingList[roomId][nickname].timer.fishing_state = true;

    var resData = {result: 'fishing', 'nickname': nickname};
    io.to(roomId).emit('fishing', AESCrypt.socketEncrypt(resData));
  }

  function fishing_end(roomId, nickname){
    console.log('fishing end '+roomId+'/'+nickname);
    if(fishingList[roomId] == undefined){
      return;
    }else if(fishingList[roomId][nickname] == undefined){
      return;
    }

    fishingList[roomId][nickname].timer = setTimeout(fishing_start, 10000+Math.random()*50000, roomId, nickname);

    var resData = {result: 'miss', 'nickname': nickname};
    io.to(roomId).emit('fishing', AESCrypt.socketEncrypt(resData));
  }
});

socket.on('getDiary', function(data){
  try {
    var decData = AESCrypt.socketDecrypt(data);
  } catch (error) {
    console.log('error:'+error);
    var rec = {'req': 'getDiary', 'reason': 'Invalid data', 'error': error, 'nickname':socket.name};
    datasetup.securityRecord(rec);
    socket.emit('wrong', AESCrypt.socketEncrypt(rec));

    socket.disconnect();
    return;
  }
  console.log('getDiary '+JSON.stringify(decData));

  if(socket.name == undefined){
    var rec = {'req': 'getDiary', 'reason': 'not_logined', data:decData};
    datasetup.securityRecord(rec);

    socket.emit('wrong', AESCrypt.socketEncrypt(rec));
    socket.disconnect();
    return;
  }

  if(decData.isDiary == undefined){
    var rec = {'req': 'getDiary', 'reason': 'Invalid isDiary data', data:decData, nickname:socket.name};
    datasetup.securityRecord(rec);

    socket.emit('wrong', AESCrypt.socketEncrypt(rec));
    socket.disconnect();
    return;
  }

  if(decData.owner == undefined || decData.owner.length < 0 || decData.owner.length > 12){
    var rec = {'req': 'getDiary', 'reason': 'Invalid owner data', data:decData, nickname:socket.name};
    datasetup.securityRecord(rec);

    socket.emit('wrong', AESCrypt.socketEncrypt(rec));
    socket.disconnect();
    return;
  }

  if(!decData.isDiary && decData.owner != socket.name){
    datasetup.checkFriend(decData.owner, socket.name, function(err, data){
      if(err){
        decData['result'] = 'fail';
        decData['error'] = err;
        socket.emit('getDiary', AESCrypt.socketEncrypt(decData));
      }else{
        if(data.length == 0){
          decData['result'] = 'not_friend';
          socket.emit('getDiary', AESCrypt.socketEncrypt(decData));
        }
      }
    });
  }
  
  datasetup.checkBlock(decData.owner, socket.name, function(err, data){
    if(err){
      decData['result'] = 'fail';
      decData['error'] = err;
      socket.emit('getDiary', AESCrypt.socketEncrypt(decData));
    }else{
      if(data.length > 0){
        decData['result'] = 'blocked';
        socket.emit('getDiary', AESCrypt.socketEncrypt(decData));
      }else{
        datasetup.getDiaryPosts(socket.name, decData.owner, decData.isDiary, function(err, data){
          if(err){
            decData['result'] = 'fail';
            decData['error'] = err;
          }else{
            decData['result'] = 'success';
            console.log(data);
            for(var i=0; i<data.length; i++){
              if(data[i].reply){
                data[i].reply = JSON.parse(data[i].reply);
              }
            }
            decData['postDatas'] = data;
          }
          socket.emit('getDiary', AESCrypt.socketEncrypt(decData));
        });
      }
    }
  });
});

socket.on('addDiary', function(data){
  try {
    var decData = AESCrypt.socketDecrypt(data);
  } catch (error) {
    console.log('error:'+error);
    var rec = {'req': 'addDiary', 'reason': 'Invalid data', 'error': error, 'nickname':socket.name};
    datasetup.securityRecord(rec);
    socket.emit('wrong', AESCrypt.socketEncrypt(rec));

    socket.disconnect();
    return;
  }
  
  console.log('addDiary '+JSON.stringify(decData));

  if(socket.name == undefined){
    var rec = {'req': 'addDiary', 'reason': 'not_logined', data:decData};
    datasetup.securityRecord(rec);

    socket.emit('wrong', AESCrypt.socketEncrypt(rec));
    socket.disconnect();
    return;
  }

  if(decData.postData == undefined
    || decData.postData.owner == undefined || decData.postData.owner.length < 1 || decData.postData.owner.length > 12
    || decData.postData.title != undefined && (decData.postData.title.length < 1 || decData.postData.title.length > 30)
    || decData.postData.content == undefined || decData.postData.content.length < 1 || decData.postData.content.length > 200
    || decData.postData.access_level == undefined || decData.postData.access_level < 1 || decData.postData.access_level > 3
    || decData.postData.owner != socket.name && decData.postData.access_level == 2){
    var rec = {'req': 'addDiary', 'reason': 'Invalid post data', data:decData, nickname:socket.name};
    datasetup.securityRecord(rec);

    socket.emit('wrong', AESCrypt.socketEncrypt(rec));
    socket.disconnect();
    return;
  }

  if(decData.postData.owner != socket.name){
    datasetup.checkFriend(decData.postData.owner, socket.name, function(err, data){
      if(err){
        decData['result'] = 'fail';
        decData['error'] = err;
        socket.emit('addDiary', AESCrypt.socketEncrypt(decData));
      }else{
        if(data.length == 0){
          decData['result'] = 'not_friend';
          socket.emit('addDiary', AESCrypt.socketEncrypt(decData));
        }
      }
    });
  }
  
  datasetup.checkBlock(decData.postData.owner, socket.name, function(err, data){
    if(err){
      decData['result'] = 'fail';
      decData['error'] = err;
      socket.emit('addDiary', AESCrypt.socketEncrypt(decData));
    }else{
      if(data.length > 0){
        decData['result'] = 'blocked';
        socket.emit('addDiary', AESCrypt.socketEncrypt(decData));
      }else{
        if(decData.postData.owner != socket.name){
          //check exist post
          datasetup.getDiaryPost(decData.postData.owner, socket.name, function(err, data){
            if(err){
              decData['result'] = 'fail';
              decData['error'] = err;
              socket.emit('addDiary', AESCrypt.socketEncrypt(decData));
            }else{
              if(data.length > 0){
                let _id = data[0]._id;
                decData.postData['_id'] = _id;
                //set diary post
                datasetup.setDiaryPost(decData.postData, function(err, data){
                  if(err){
                    decData['result'] = 'fail';
                    decData['error'] = err;
                  }else{
                    decData['result'] = 'success';
                    decData.postData['writer'] = socket.name;
                    decData.postData['reply'] = null;
                  }
                  socket.emit('setDiary', AESCrypt.socketEncrypt(decData));
                });
              }else{
                //add diary post
                datasetup.addDiaryPost(socket.name, decData.postData, function(err, data){
                  if(err){
                    decData['result'] = 'fail';
                    decData['error'] = err;
                  }else{
                    decData['result'] = 'success';
                    decData.postData['_id'] = data.insertId;
                    decData.postData['writer'] = socket.name;
                    decData.postData['reply'] = null;
                  }
                  socket.emit('addDiary', AESCrypt.socketEncrypt(decData));
                });
              }
            }
          });
        }else{
          datasetup.addDiaryPost(socket.name, decData.postData, function(err, data){
            if(err){
              decData['result'] = 'fail';
              decData['error'] = err;
            }else{
              decData['result'] = 'success';
              decData.postData['_id'] = data.insertId;
              decData.postData['writer'] = socket.name;
              decData.postData['reply'] = null;
            }
            socket.emit('addDiary', AESCrypt.socketEncrypt(decData));
          });
        }
      }
    }
  });
});

socket.on('setDiary', function(data){
  try {
    var decData = AESCrypt.socketDecrypt(data);
  } catch (error) {
    console.log('error:'+error);
    var rec = {'req': 'setDiary', 'reason': 'Invalid data', 'error': error, 'nickname':socket.name};
    datasetup.securityRecord(rec);
    socket.emit('wrong', AESCrypt.socketEncrypt(rec));

    socket.disconnect();
    return;
  }
  console.log('setDiary '+JSON.stringify(decData));

  if(socket.name == undefined){
    var rec = {'req': 'setDiary', 'reason': 'not_logined', data:decData};
    datasetup.securityRecord(rec);

    socket.emit('wrong', AESCrypt.socketEncrypt(rec));
    socket.disconnect();
    return;
  }

  if(decData.postData == undefined
    || decData.postData._id == undefined
    || decData.postData.owner == undefined || decData.postData.owner.length < 1 || decData.postData.owner.length > 12
    || decData.postData.title != undefined && (decData.postData.title.length < 1 || decData.postData.title.length > 30)
    || decData.postData.content == undefined || decData.postData.content.length < 1 || decData.postData.content.length > 200
    || decData.postData.access_level == undefined || decData.postData.access_level < 1 || decData.postData.access_level > 3
    || decData.postData.owner != socket.name && decData.postData.access_level == 2){
    var rec = {'req': 'setDiary', 'reason': 'Invalid post data', data:decData, nickname:socket.name};
    datasetup.securityRecord(rec);

    socket.emit('wrong', AESCrypt.socketEncrypt(rec));
    socket.disconnect();
    return;
  }

  if(decData.postData.owner != socket.name){
    datasetup.checkFriend(decData.postData.owner, socket.name, function(err, data){
      if(err){
        decData['result'] = 'fail';
        decData['error'] = err;
        socket.emit('setDiary', AESCrypt.socketEncrypt(decData));
      }else{
        if(data.length == 0){
          decData['result'] = 'not_friend';
          socket.emit('setDiary', AESCrypt.socketEncrypt(decData));
        }
      }
    });
  }
  
  datasetup.checkBlock(decData.postData.owner, socket.name, function(err, data){
    if(err){
      decData['result'] = 'fail';
      decData['error'] = err;
      socket.emit('setDiary', AESCrypt.socketEncrypt(decData));
    }else{
      if(data.length > 0){
        decData['result'] = 'blocked';
        socket.emit('setDiary', AESCrypt.socketEncrypt(decData));
      }else{
        datasetup.checkDiaryPost(decData.postData._id, function(err, data){
          if(err){
            decData['result'] = 'fail';
            decData['error'] = err;
            socket.emit('setDiary', AESCrypt.socketEncrypt(decData));
          }else{
            if(data.length > 0 && data[0].writer == socket.name){
              datasetup.setDiaryPost(decData.postData, function(err, data){
                if(err){
                  decData['result'] = 'fail';
                  decData['error'] = err;
                }else{
                  decData['result'] = 'success';
                }
                socket.emit('setDiary', AESCrypt.socketEncrypt(decData));
              });
            }else{
              var rec = {'req': 'setDiary', 'reason': 'No post or Can not edit', data:decData, nickname:socket.name};
              datasetup.securityRecord(rec);
      
              socket.emit('wrong', AESCrypt.socketEncrypt(rec));
              socket.disconnect();
              return;
            }
          }
        });
      }
    }
  });

});

socket.on('deleteDiary', function(data){
  try {
    var decData = AESCrypt.socketDecrypt(data);
  } catch (error) {
    console.log('error:'+error);
    var rec = {'req': 'deleteDiary', 'reason': 'Invalid data', 'error': error, 'nickname':socket.name};
    datasetup.securityRecord(rec);
    socket.emit('wrong', AESCrypt.socketEncrypt(rec));

    socket.disconnect();
    return;
  }
  console.log('deleteDiary '+JSON.stringify(decData));

  if(socket.name == undefined){
    var rec = {'req': 'deleteDiary', 'reason': 'not_logined', data:decData};
    datasetup.securityRecord(rec);

    socket.emit('wrong', AESCrypt.socketEncrypt(rec));
    socket.disconnect();
    return;
  }

  if(decData._id == undefined){
    var rec = {'req': 'deleteDiary', 'reason': 'Invalid _id data', data:decData, nickname:socket.name};
    datasetup.securityRecord(rec);

    socket.emit('wrong', AESCrypt.socketEncrypt(rec));
    socket.disconnect();
    return;
  }
  
  datasetup.checkDiaryPost(decData._id, function(err, data){
    if(err){
      decData['result'] = 'fail';
      decData['error'] = err;
      socket.emit('deleteDiary', AESCrypt.socketEncrypt(decData));
    }else{
      if(data.length > 0 && (data[0].writer == socket.name || data[0].owner == socket.name)){
        datasetup.deleteDiaryPost(decData._id, function(err, data){
          if(err){
            decData['result'] = 'fail';
            decData['error'] = err;
          }else{
            decData['result'] = 'success';
          }
          socket.emit('deleteDiary', AESCrypt.socketEncrypt(decData));
        });
      }else{
        var rec = {'req': 'deleteDiary', 'reason': 'No post or Can not delete', data:decData, nickname:socket.name};
        datasetup.securityRecord(rec);

        socket.emit('wrong', AESCrypt.socketEncrypt(rec));
        socket.disconnect();
        return;
      }
    }
  });
});

socket.on('setReply', function(data){
  try {
    var decData = AESCrypt.socketDecrypt(data);
  } catch (error) {
    console.log('error:'+error);
    var rec = {'req': 'setReply', 'reason': 'Invalid data', 'error': error, 'nickname':socket.name};
    datasetup.securityRecord(rec);
    socket.emit('wrong', AESCrypt.socketEncrypt(rec));

    socket.disconnect();
    return;
  }
  console.log('setReply '+JSON.stringify(decData));

  if(socket.name == undefined){
    var rec = {'req': 'setReply', 'reason': 'not_logined', data:decData};
    datasetup.securityRecord(rec);

    socket.emit('wrong', AESCrypt.socketEncrypt(rec));
    socket.disconnect();
    return;
  }

  if(decData._id == undefined
    || decData.content == undefined || decData.content.length < 1 || decData.content.length > 200){
    var rec = {'req': 'setReply', 'reason': 'Invalid _id or content data', data:decData, nickname:socket.name};
    datasetup.securityRecord(rec);

    socket.emit('wrong', AESCrypt.socketEncrypt(rec));
    socket.disconnect();
    return;
  }

  var replyData = {content: decData.content};

  datasetup.checkDiaryPost(decData._id, function(err, data){
    if(err){
      decData['result'] = 'fail';
      decData['error'] = err;
      socket.emit('setReply', AESCrypt.socketEncrypt(decData));
    }else{
      if(data.length > 0 && data[0].owner == socket.name){
        datasetup.setDiaryPostReply(decData._id, replyData, function(err, data){
          if(err){
            decData['result'] = 'fail';
            decData['error'] = err;
          }else{
            decData['result'] = 'success';
            decData['replyData'] = replyData;
          }   
          socket.emit('setReply', AESCrypt.socketEncrypt(decData));
        });
      }else{
        var rec = {'req': 'setReply', 'reason': 'No post or Can not reply', data:decData, nickname:socket.name};
        datasetup.securityRecord(rec);

        socket.emit('wrong', AESCrypt.socketEncrypt(rec));
        socket.disconnect();
        return;
      }
    }
  });
});

socket.on('deleteReply', function(data){
  try {
    var decData = AESCrypt.socketDecrypt(data);
  } catch (error) {
    console.log('error:'+error);
    var rec = {'req': 'deleteReply', 'reason': 'Invalid data', 'error': error, 'nickname':socket.name};
    datasetup.securityRecord(rec);
    socket.emit('wrong', AESCrypt.socketEncrypt(rec));

    socket.disconnect();
    return;
  }
  console.log('deleteReply '+JSON.stringify(decData));

  if(socket.name == undefined){
    var rec = {'req': 'deleteReply', 'reason': 'not_logined', data:decData};
    datasetup.securityRecord(rec);

    socket.emit('wrong', AESCrypt.socketEncrypt(rec));
    socket.disconnect();
    return;
  }

  if(decData._id == undefined){
    var rec = {'req': 'deleteReply', 'reason': 'Invalid _id data', data:decData, nickname:socket.name};
    datasetup.securityRecord(rec);

    socket.emit('wrong', AESCrypt.socketEncrypt(rec));
    socket.disconnect();
    return;
  }

  datasetup.checkDiaryPost(decData._id, function(err, data){
    if(err){
      decData['result'] = 'fail';
      decData['error'] = err;
      socket.emit('deleteReply', AESCrypt.socketEncrypt(decData));
    }else{
      if(data.length > 0 && data[0].owner == socket.name){
        datasetup.deleteDiaryPostReply(decData._id, function(err, data){
          if(err){
            decData['result'] = 'fail';
            decData['error'] = err;
          }else{
            decData['result'] = 'success';
          }
          socket.emit('deleteReply', AESCrypt.socketEncrypt(decData));
        });
      }else{
        var rec = {'req': 'deleteReply', 'reason': 'No post or Can not delete reply', data:decData, nickname:socket.name};
        datasetup.securityRecord(rec);

        socket.emit('wrong', AESCrypt.socketEncrypt(rec));
        socket.disconnect();
        return;
      }
    }
  });
});

socket.on('piano', function(){
  if(socket.name == undefined){
    var rec = {'req': 'piano', 'reason': 'not_logined'};
    datasetup.securityRecord(rec);

    socket.emit('wrong', AESCrypt.socketEncrypt(rec));
    socket.disconnect();
    return;
  }
  
  if(checkRoom('@piano')){
    return;
  }
  
  //find room
  var roomId, newRoomId;
  var keyList = Object.keys(pianoList);
  keyList.splice(0, 1);
  if(keyList.length > 0){
    var last = keyList[keyList.length-1];
    last = last.slice(6, last.length);
    last = parseInt(last)+1;
    
    for (var i=0; i<last; i++) {
      let key = '@piano'+i;
      if(pianoList[key] == undefined && newRoomId == undefined){
        newRoomId = key;
      }else if (keyList.includes(key) && Object.keys(pianoList[key]).length < 5) {
        roomId = key;
        break;
      }
    }
  }

  if(roomId == undefined){
    if(newRoomId == undefined){
      roomId = '@piano'+keyList.length;
    }else{
      roomId = newRoomId;
    }
  }
  
  var resData = {};
  if(pianoList[roomId] == undefined){
    pianoList[roomId] = {};
    pianoList[roomId][socket.name] = {x: 0, y: 0};

    resData['result'] = 'success';
    resData['room'] = roomId;

    socket.join(roomId);
    socket.room = roomId;
  
    socket.emit('piano', AESCrypt.socketEncrypt(resData));
    
  }else{
    var toRoom = {};
    let nicknames = Object.keys(pianoList[roomId]);
    //TODO database
    datasetup.getUserFromNick(socket.name, function(err, data){
      if(err){
        resData['result'] = 'fail';
        resData['error'] = err;
        socket.emit('piano', AESCrypt.socketEncrypt(resData));
      }else{
        toRoom['result'] = 'enter';
        toRoom['userData'] = data[0];

        datasetup.getUsersFromNick(nicknames, function(err, data){
          if(err){
            resData['result'] = 'fail'
            resData['error'] = err;
            socket.emit('piano', AESCrypt.socketEncrypt(resData));
          }else{
            for(var i=0; i<data.length; i++){
              data[i]['x'] = pianoList[roomId][data[i].nickname].x;
              data[i]['y'] = pianoList[roomId][data[i].nickname].y;
            }
            resData['userDatas'] = data;
            io.to(roomId).emit('piano', AESCrypt.socketEncrypt(toRoom));

            pianoList[roomId][socket.name] = {x: 0, y: 0};
    
            resData['result'] = 'success';
            resData['room'] = roomId;
    
            socket.join(roomId);
            socket.room = roomId;
            socket.emit('piano', AESCrypt.socketEncrypt(resData));
          }
        });
      }
    });
  }
});

function checkRoom(currentRoom){
  var roomsList = ['@dice', '@foothold', '@blinddate', '@fishing', '@piano', '@hangman', '@running'];
  let currentIndex = roomsList.indexOf(currentRoom);
  if(currentIndex >= 0){
    roomsList.splice(currentIndex, 1);
  }

  if(socket.room != undefined){
    if(socket.room.includes(currentRoom)){
      return true;
    }else{
      for(var i=0;i<roomsList.length;i++){
        if(socket.room.includes(roomsList[i])){
          var rec = {'req': currentRoom.slice(1), 'reason': 'Invalid_request', 'nickname':socket.name};
          datasetup.securityRecord(rec);

          socket.emit('wrong', AESCrypt.socketEncrypt(rec));
          socket.disconnect();
          return true;
        }
      }
    }

    if(leaveRoom(socket)){
      return true;
    }
  }

  return false;
}

socket.on('hangman', function(data){
  try {
    var decData = AESCrypt.socketDecrypt(data);
  } catch (error) {
    console.log('error:'+error);
    var rec = {'req': 'hangman', 'reason': 'Invalid data', 'error': error, 'nickname':socket.name};
    datasetup.securityRecord(rec);
    socket.emit('wrong', AESCrypt.socketEncrypt(rec));

    socket.disconnect();
    return;
  }
  console.log('hangman '+JSON.stringify(decData));

  if(socket.name == undefined){
    var rec = {'req': 'hangman', 'reason': 'not_logined', data: decData};
    datasetup.securityRecord(rec);

    socket.emit('wrong', AESCrypt.socketEncrypt(rec));
    socket.disconnect();
    return;
  }

  if(decData.type == 'enter'){
    if(checkRoom('@hangman')){
      return;
    }

    //find room
    var roomId = hangman_find_room();
    if(hangmanList[roomId] && hangmanList[roomId].timer == undefined){
      console.log(roomId+ '/timer undefined');
      roomId = hangman_find_room();
      if(hangmanList[roomId] && hangmanList[roomId].timer == undefined){
        console.log(roomId+ '/timer undefined2');
        return;
      }
    }

    if(hangmanList[roomId] == undefined){
      hangmanList[roomId] = {};
      hangmanList[roomId]['userList'] = {};
      hangmanList[roomId]['indexList'] = [undefined, undefined, undefined, undefined, undefined];
      hangmanList[roomId]['timer'] = setTimeout(hangman_start, 15000, roomId);
      hangmanList[roomId].timer._now = Date.now();

      hangmanList[roomId].indexList[0] = socket.name;
      hangmanList[roomId].userList[socket.name] = {x:hangmanList.waitLoc[0], y:-380, isCanAnswer:true, answer:[], timer:null};
      socket.room = roomId;
      socket.join(roomId);

      decData['result'] = 'enter';
      decData['room'] = roomId;
      decData['leftTime'] = 15;
      decData['pos_x'] = hangmanList.waitLoc[0];
      decData['pos_y'] = -380;
      socket.emit('hangman', AESCrypt.socketEncrypt(decData));

    }else{
      var toRoom = {};
      let nicknames = Object.keys(hangmanList[roomId].userList);
      //TODO database
      datasetup.getUserFromNick(socket.name, function(err, data){
        if(err){
          decData['result'] = 'fail';
          decData['error'] = err;
          socket.emit('hangman', AESCrypt.socketEncrypt(decData));
        }else{
          toRoom['result'] = 'enter';
          toRoom['userData'] = data[0];

          datasetup.getUsersFromNick(nicknames, function(err, data){
            if(err){
              decData['result'] = 'fail'
              decData['error'] = err;
              socket.emit('hangman', AESCrypt.socketEncrypt(decData));
            }else{
              // set location
              var index;
              for(var i=0; i<hangmanList[roomId].indexList.length; i++){
                if(hangmanList[roomId].indexList[i] == undefined){
                  index = i;
                  hangmanList[roomId].indexList[i] = socket.name;
                  break;
                }
              }
              hangmanList[roomId].userList[socket.name] = {x:hangmanList.waitLoc[index], y:-380, isCanAnswer:true, answer:[]};

              toRoom.userData['x'] = hangmanList.waitLoc[index];
              toRoom.userData['y'] = -380;
              io.to(roomId).emit('hangman', AESCrypt.socketEncrypt(toRoom));

              console.log(roomId+"/"+hangmanList[roomId]+"/"+hangmanList[roomId].timer);
              decData['result'] = 'enter';
              decData['room'] = roomId;
              decData['leftTime'] = getTimeLeft(hangmanList[roomId].timer);
              decData['pos_x'] = hangmanList.waitLoc[index];
              decData['pos_y'] = -380;
              for (var j=0; j<data.length; j++) {
                data[j]['x'] = hangmanList[roomId].userList[data[j].nickname].x;
                data[j]['y'] = hangmanList[roomId].userList[data[j].nickname].y;
              }
              decData['userDatas'] = data;
              socket.emit('hangman', AESCrypt.socketEncrypt(decData));

              socket.room = roomId;
              socket.join(roomId);

              // start if room is full
              if(data.length == 4){
                clearTimeout(hangmanList[roomId].timer);
                hangman_start(roomId);
              }
            }
          });
        }
      });
    }
  }else if(decData.type == 'answer'){
    if(decData.letter == undefined || decData.letter.length != 1 || decData.letter.match(/[^a-z]/i) != null){
      var rec = {'req': 'hangman', 'reason': 'Invalid letter data', data: decData, nickname: socket.name};
      datasetup.securityRecord(rec);

      socket.emit('wrong', AESCrypt.socketEncrypt(rec));
      socket.disconnect();
      return;
    }

    if(hangmanList[socket.room] == undefined
      || hangmanList[socket.room].word == undefined || hangmanList[socket.room].current == undefined){
      return;
    }else if(!hangmanList[socket.room].userList[socket.name].isCanAnswer){
      return;
    }else if(hangmanList[socket.room].current.includes(decData.letter)){
      //exist answer
      return;
    }else if(hangmanList[socket.room].word.includes(decData.letter)){
      //new answer
      datasetup.addFastCash(socket.name, 10, function(err, data){
        if(err){
          decData['result'] = 'fail';
          decData['error'] = err;
        }else{
          hangmanList[socket.room].userList[socket.name].answer.push(decData.letter);
          var index = hangmanList[socket.room].word.indexOf(decData.letter);
          while(index >= 0){
            hangmanList[socket.room].current = replaceAt(hangmanList[socket.room].current, index, decData.letter);
            index = hangmanList[socket.room].word.indexOf(decData.letter, index+1);
          }
          console.log(hangmanList[socket.room].current);
          
          decData['result'] = 'correct';
          decData['from'] = socket.name;
          decData['current'] = hangmanList[socket.room].current;
          decData['score'] = 10;

          if(hangmanList[socket.room].current.includes('_')){
            io.to(socket.room).emit('hangman', AESCrypt.socketEncrypt(decData));

          }else{
            //game clear
            let nicknames = Object.keys(hangmanList[socket.room].userList);
            datasetup.getUsersFromNick(nicknames, function(err, data){
              if(err){
                decData['result'] = 'fail';
                decData['error'] = err;
              }else{
                decData['userDatas'] = data;
                var toprankers = {top:0, rankers:[]};
                for(var i=0; i<decData.userDatas.length; i++){
                  let nick = decData.userDatas[i].nickname;
                  if(nick != undefined){
                    decData.userDatas[i].answer = hangmanList[socket.room].userList[nick].answer;
                    if(toprankers.top < hangmanList[socket.room].userList[nick].answer.length){
                      toprankers.top = hangmanList[socket.room].userList[nick].answer.length;
                      toprankers.rankers = [nick];
                    }else if(toprankers.top == hangmanList[socket.room].userList[nick].answer.length){
                      toprankers.rankers.push(nick);
                    }
                  }
                }

                if(toprankers.top > 0){
                  for(var i=0; i<toprankers.rankers.length; i++){
                    datasetup.addUserCash(toprankers.rankers[i], 10, function(err, data){
                      if(!err){
                        for(var j=0; j<decData.userDatas.length; j++){
                          if(toprankers.rankers[i] == decData.userDatas[j].nickname){
                            decData.userDatas[j].score = 10;
                            break;
                          }
                        }
                      }
                    });
                  }
                }

                io.to(socket.room).emit('hangman', AESCrypt.socketEncrypt(decData));

                //leave and delete room
                let nicknames = Object.keys(hangmanList[socket.room].userList);
                let roomId = socket.room;
                for(var i=0; i<nicknames.length; i++){
                  if(userList[nicknames[i]] == undefined){
                    var rec = {'req': 'hangman', 'reason': 'no user', "nickname": nicknames[i]};
                    datasetup.securityRecord(rec);
                    continue;
                  }

                  if(hangmanList[roomId].userList[nicknames[i]].timer){
                    clearTimeout(hangmanList[roomId].userList[nicknames[i]].timer);
                    // delete hangmanList[roomId].userList[nicknames[i]].timer;
                  }

                  userList[nicknames[i]].leave(roomId);
                  delete userList[nicknames[i]].room;
                }
                delete hangmanList[roomId];
              }
            });
          }
        }
      });
    }else{
      //wrong answer
      hangmanList[socket.room].userList[socket.name].isCanAnswer = false;
      hangmanList[socket.room].userList[socket.name].timer = setTimeout(() => {
        console.log('isCanAnswer timer '+socket.name+'/'+hangmanList[socket.room] != undefined);
        if(hangmanList[socket.room] == undefined){
          return;
        }
        hangmanList[socket.room].userList[socket.name].isCanAnswer = true;
        delete hangmanList[socket.room].userList[socket.name].timer;
      }, 5000);

      decData['result'] = 'wrong';
      decData['from'] = socket.name;
      decData['leftTime'] = 5;
      io.to(socket.room).emit('hangman', AESCrypt.socketEncrypt(decData));
    }
    
  }else{
    var rec = {'req': 'hangman', 'reason': 'Invalid type data', data: decData, nickname: socket.name};
    datasetup.securityRecord(rec);

    socket.emit('wrong', AESCrypt.socketEncrypt(rec));
    socket.disconnect();
    return;
  }

  function hangman_start(roomId){
    console.log(roomId+' start');
    if(hangmanList[roomId] == undefined){
      return;
    }

    delete hangmanList[roomId].timer;
    hangmanList[roomId]['word'] = datasetup.getHangmanWord().data[0].word;
    hangmanList[roomId]['current'] = "_".repeat(hangmanList[roomId].word.length);
    io.to(roomId).emit('hangman', AESCrypt.socketEncrypt({result:'start', current: hangmanList[roomId].current}));
    console.log(hangmanList[roomId].word);
  }

  function hangman_find_room(){
    //find room
    var roomId, newRoomId;
    var keyList = Object.keys(hangmanList);
    console.log(keyList);
    keyList.splice(0,1);
    var last = 0;
    if(keyList.length > 0){
      last = keyList[keyList.length-1];
      last = last.slice(8, last.length);
      last = parseInt(last)+1;
      
      for (var i=0; i<last; i++) {
        let key = '@hangman'+i;
        if(hangmanList[key] == undefined && newRoomId == undefined){
          newRoomId = key;
        }else if (keyList.includes(key) && hangmanList[key].timer) {
          roomId = key;
          break;
        }
      }
    }

    if(roomId == undefined){
      if(newRoomId == undefined){
        roomId = '@hangman'+last;
      }else{
        roomId = newRoomId;
      }
    }

    return roomId;
  }

});

socket.on('fountain', function(data){
  try {
    var decData = AESCrypt.socketDecrypt(data);
  } catch (error) {
    console.log('error:'+error);
    var rec = {'req': 'fountain', 'reason': 'Invalid data', 'error': error, 'nickname':socket.name};
    datasetup.securityRecord(rec);
    socket.emit('wrong', AESCrypt.socketEncrypt(rec));

    socket.disconnect();
    return;
  }
  console.log('fountain '+JSON.stringify(decData));

  if(socket.name == undefined){
    var rec = {'req': 'fountain', 'reason': 'not_logined', data:decData};
    datasetup.securityRecord(rec);
    socket.emit('wrong', AESCrypt.socketEncrypt(rec));

    socket.disconnect();
    return;
  }

  if(decData.type == 'rank'){
    datasetup.getFountainRank(socket.name,function(err, data, user){
      if(err){
        decData['result'] = 'fail';
        decData['error'] = err;
        socket.emit('fountain', AESCrypt.socketEncrypt(decData));
      }else{
        var nicknames = [];
        for(var i=0; i<data.length; i++){
          nicknames.push(data[i].nickname);
          data[i].cash = data[i].cash.toString();
        }
        decData['fountainData'] = data;
        if(user.length>0){
          decData['usercash'] = user[0].cash.toString();
        } else {
          decData['usercash'] = '0';
        }
        datasetup.getUsersFromNick(nicknames, function(err, data){
          if(err){
            decData['result'] = 'fail';
            decData['error'] = err;
          }else{
            decData['result'] = 'success';
            
            var userDatas = {};
            for(var i=0; i<data.length; i++){
              userDatas[data[i].nickname] = data[i];
            }
            decData['userDatas'] = userDatas;
          }
          socket.emit('fountain', AESCrypt.socketEncrypt(decData));
        });
      }
    });
  }else if(decData.type == 'coin'){
    if(decData.coin == undefined){
      var rec = {'req': 'fountain', 'reason': 'Invalid coin data', 'error': error, 'nickname':socket.name, data:decData};
      datasetup.securityRecord(rec);
      socket.emit('wrong', AESCrypt.socketEncrypt(rec));
  
      socket.disconnect();
      return;
    }

    datasetup.getUserFromNick(socket.name, function(err, data){
      if(err){
        decData['result'] = 'fail';
        decData['error'] = err;
        socket.emit('fountain', AESCrypt.socketEncrypt(decData));
      }else{
        if(data[0].cash < decData.coin){
          var rec = {'req': 'fountain', 'reason': 'Invalid coin data', 'error': error, 'nickname':socket.name, data:decData};
          datasetup.securityRecord(rec);

          decData['result'] = 'less_cash';
          socket.emit('fountain', AESCrypt.socketEncrypt(decData));
        }else{
          datasetup.addFountainCash(socket.name, decData.coin, function(err, data){
            if(err){
              decData['result'] = 'fail';
              decData['error'] = err;
            }else{
              decData['result'] = 'success';
            }
            socket.emit('fountain', AESCrypt.socketEncrypt(decData));
          });
        }
      }
    });
  }else{
    var rec = {'req': 'fountain', 'reason': 'Invalid type data', 'error': error, 'nickname':socket.name, data:decData};
    datasetup.securityRecord(rec);
    socket.emit('wrong', AESCrypt.socketEncrypt(rec));

    socket.disconnect();
    return;
  }
  
});

socket.on('adopt', function(data){
  try {
    var decData = AESCrypt.socketDecrypt(data);
  } catch (error) {
    console.log('error:'+error);
    var rec = {'req': 'adopt', 'reason': 'Invalid data', 'error': error, 'nickname':socket.name};
    datasetup.securityRecord(rec);
    socket.emit('wrong', AESCrypt.socketEncrypt(rec));

    socket.disconnect();
    return;
  }
  console.log('adopt '+JSON.stringify(decData));

  if(socket.name == undefined){
    var rec = {'req': 'adopt', 'reason': 'not_logined', 'error': error, data:decData};
    datasetup.securityRecord(rec);
    socket.emit('wrong', AESCrypt.socketEncrypt(rec));

    socket.disconnect();
    return;
  }

  if(decData.type == 'get'){
    //nickname
    if(decData.nickname == undefined || decData.nickname.length < 0 || decData.nickname.length > 12){
      var rec = {'req': 'adopt', 'reason': 'Invalid nickname data', 'data': decData, nickname:socket.name};
      datasetup.securityRecord(rec);
      socket.emit('wrong', AESCrypt.socketEncrypt(rec));

      socket.disconnect();
      return;
    }

    datasetup.getAdopt(decData.nickname, function(err, data){
      if(err){
        decData['result'] = 'fail';
        decData['error'] = err;
      }else{
        decData['result'] = 'success';

        for(var i=0; i<data.length; i++){
          if(data[i].adoptData){
            data[i].adoptData = JSON.parse(data[i].adoptData);
          }
        }
        decData['adoptData'] = data;
      }
      socket.emit('adopt', AESCrypt.socketEncrypt(decData));
    });

  }else if(decData.type == 'add'){
    datasetup.getAdopt(socket.name, function(err,data){
      if(err){
        resData['result'] = 'fail';
        resData['error'] = err;
        socket.emit('adopt', AESCrypt.socketEncrypt(resData));
      }else{
        var adoptNum = data.length;
        if(adoptNum > 2){
          return;
        }
        datasetup.getUserFromNick(socket.name, function(err, data){
          if(err){
            decData['result'] = 'fail';
            decData['error'] = err;
            socket.emit('adopt', AESCrypt.socketEncrypt(decData));
          }else{
            let cash = data[0].cash;
            if(cash >= datasetup.protocol.slot_value[adoptNum]){
              datasetup.addAdopt(socket.name, adoptNum, function(err, data){
                if(err){
                  decData['result'] = 'fail';
                  decData['error'] = err;
                }else{
                  cash -= datasetup.protocol.slot_value[adoptNum];
                  decData['result'] = 'success';
                  decData['adoptNum'] = adoptNum;
                  decData['cash'] = String(cash);
                }
                socket.emit('adopt', AESCrypt.socketEncrypt(decData));
              });
            }else{
              decData['result'] = 'not_enough_cash';
              socket.emit('adopt', AESCrypt.socketEncrypt(decData));
            }
          }
        });
      }
    });
  }else if(decData.type == 'adopt'){
    //adoptNum, nickname
    if (decData.nickname == undefined || decData.adoptNum == undefined) {
      var rec = {'req': 'adopt', 'reason': 'data undefined', 'data': decData, nickname:socket.name};
      datasetup.securityRecord(rec);
      socket.emit('wrong', AESCrypt.socketEncrypt(rec));
  
      socket.disconnect();
      return;
    }
  
    var nick = decData.nickname.trim();
    if (nick.length < 1 || nick.length > 12) {
      var rec = {'req': 'adopt', 'reason': 'nickname length', 'data': decData, nickname:socket.name};
      datasetup.securityRecord(rec);
      socket.emit('wrong', AESCrypt.socketEncrypt(rec));
  
      socket.disconnect();
      return;
    }
  
    if (nick.includes('@') || nick.includes('/') || nick.includes('\\') || nick.includes('"') || nick.includes(' ')) {
      var rec = {'req': 'adopt', 'reason': 'Invalid nickname', 'data': decData, nickname:socket.name};
      datasetup.securityRecord(rec);
      socket.emit('wrong', AESCrypt.socketEncrypt(rec));
  
      socket.disconnect();
      return;
    }

    datasetup.checkAdopt(socket.name, decData.adoptNum, function(err, data){
      if(err){
        decData['result'] = 'fail';
        decData['error'] = err;
        socket.emit('adopt', AESCrypt.socketEncrypt(decData));
      }else{
        if(data.length > 0 && data[0].adoptData == undefined){
          datasetup.getUserFromNick(socket.name, function(err, data){
            if(err){
              decData['result'] = 'fail';
              decData['error'] = err;
              socket.emit('adopt', AESCrypt.socketEncrypt(decData));
            }else{
              var adoptData = {
                nickname:decData.nickname,
                hair:data[0].hair,
                face:data[0].face,
                bottom:data[0].bottom,
                shoes:data[0].shoes,
                skin:data[0].skin,
                top:data[0].top,
                hairac:data[0].hairac
              };
              
              datasetup.setAdoptData(socket.name, decData.adoptNum, adoptData, function(err, data){
                if(err){
                  decData['result'] = 'fail';
                  decData['error'] = err;
                }else{
                  decData['result'] = 'success';
                  decData['adoptData'] = adoptData;
                }
                socket.emit('adopt', AESCrypt.socketEncrypt(decData));
              });
            }
          });
        }else{
          var rec = {'req': 'adopt', 'reason': 'Invalid adoptNum', 'data': decData, nickname:socket.name};
          datasetup.securityRecord(rec);
          socket.emit('wrong', AESCrypt.socketEncrypt(rec));
      
          socket.disconnect();
          return;
        }
      }
    });
  }else if(decData.type == 'delete'){
    //adoptNum
    if(decData.adoptNum == undefined){
      var rec = {'req': 'adopt', 'reason': 'adoptNum undefined', 'data': decData, nickname:socket.name};
      datasetup.securityRecord(rec);
      socket.emit('wrong', AESCrypt.socketEncrypt(rec));
  
      socket.disconnect();
      return;
    }

    datasetup.checkAdopt(socket.name, decData.adoptNum, function(err, data){
      if(err){
        decData['result'] = 'fail';
        decData['error'] = err;
        socket.emit('adopt', AESCrypt.socketEncrypt(decData));
      }else{
        if(data.length > 0){
          if(data[0].adoptData){
            data[0].adoptData = JSON.parse(data[0].adoptData);
            let nickname = data[0].adoptData.nickname;
            datasetup.deleteAdopt(socket.name, decData.adoptNum, function(err, data){
              if(err){
                decData['result'] = 'fail';
                decData['error'] = err;
              }else{
                decData['result'] = 'success';
                decData['nickname'] = nickname;
              }
              socket.emit('adopt', AESCrypt.socketEncrypt(decData));
            });
          }else{
            var rec = {'req': 'adopt', 'reason': 'No adopt data', 'data': decData, nickname:socket.name};
            datasetup.securityRecord(rec);
            socket.emit('wrong', AESCrypt.socketEncrypt(rec));
        
            socket.disconnect();
            return;
          }
        }else{
          var rec = {'req': 'adopt', 'reason': 'Invalid adoptNum', 'data': decData, nickname:socket.name};
          datasetup.securityRecord(rec);
          socket.emit('wrong', AESCrypt.socketEncrypt(rec));
      
          socket.disconnect();
          return;
        }
      }
    });
  }else if(decData.type == 'raise'){
    //adoptNum, status
    if(decData.adoptNum == undefined || decData.status == undefined
    || decData.status != "stamina" && decData.status != "speed"){
      var rec = {'req': 'adopt', 'reason': 'Invalid data', 'data': decData, nickname:socket.name};
      datasetup.securityRecord(rec);
      socket.emit('wrong', AESCrypt.socketEncrypt(rec));
  
      socket.disconnect();
      return;
    }

    datasetup.checkAdopt(socket.name, decData.adoptNum, function(err, data){
      if(err){
        decData['result'] = 'fail';
        decData['error'] = err;
        socket.emit('adopt', AESCrypt.socketEncrypt(decData));
      }else{
        if(data.length > 0){
          let amount = data[0][decData.status]+1;
          if(decData.status == 'stamina' && amount > 10000
            || decData.status == 'speed' && amount > 1000){
            var rec = {'req': 'adopt', 'reason': 'Invalid raise request', 'data': decData, nickname:socket.name};
            datasetup.securityRecord(rec);
            socket.emit('wrong', AESCrypt.socketEncrypt(rec));
        
            socket.disconnect();
            return;
          }

          datasetup.getUserFromNick(socket.name, function(err, data){
            if(err){
              decData['result'] = 'fail';
              decData['error'] = err;
              socket.emit('adopt', AESCrypt.socketEncrypt(decData));
            }else{
              var cash = data[0].cash;
              if(cash < amount){
                decData['result'] = 'not_enough_cash';
                socket.emit('adopt', AESCrypt.socketEncrypt(decData));
              }else{
                datasetup.raiseAdopt(socket.name, decData.adoptNum, decData.status, amount, function(err, data){
                  if(err){
                    decData['result'] = 'fail';
                    decData['error'] = err;
                  }else{
                    cash -= amount;
                    decData['result'] = 'success';
                    decData['level'] = amount;
                    decData['cash'] = String(cash);
                  }
                  socket.emit('adopt', AESCrypt.socketEncrypt(decData));
                });
              }
            }
          });
        }else{
          var rec = {'req': 'adopt', 'reason': 'Invalid adoptNum', 'data': decData, nickname:socket.name};
          datasetup.securityRecord(rec);
          socket.emit('wrong', AESCrypt.socketEncrypt(rec));
      
          socket.disconnect();
          return;
        }
      }
    });
  }else{
    var rec = {'req': 'adopt', 'reason': 'Invalid type data', 'error': error, 'nickname':socket.name, data:decData};
    datasetup.securityRecord(rec);
    socket.emit('wrong', AESCrypt.socketEncrypt(rec));

    socket.disconnect();
    return;
  }
});

socket.on('running', function(data){
  try {
    var decData = AESCrypt.socketDecrypt(data);
  } catch (error) {
    console.log('error:'+error);
    var rec = {'req': 'running', 'reason': 'Invalid data', 'error': error, 'nickname':socket.name};
    datasetup.securityRecord(rec);
    socket.emit('wrong', AESCrypt.socketEncrypt(rec));

    socket.disconnect();
    return;
  }
  // console.log('running '+JSON.stringify(decData));
  
  if (socket.name == undefined) {
    var rec = {'req': 'running', 'reason': 'not_logined', data:decData};
    datasetup.securityRecord(rec);

    socket.emit('wrong', AESCrypt.socketEncrypt(rec));
    socket.disconnect();
    return;
  }

  if(decData.type == 'enter'){
    //send leave to room
    if(checkRoom('@running')){
      return;
    }
    
    //except full room
    var roomId, newRoomId;
    var keyList = Object.keys(runningList);
    let keyLength = keyList.length;
    if(keyLength > 0){
      var last = keyList[keyList.length-1];
      last = last.slice(8, last.length);
      last = parseInt(last)+1;
      for (var i=last-1; i>=0; i--) {
        let key = '@running'+i;
        let key_index = keyList.indexOf(key);
        if(runningList[key] == undefined && newRoomId == undefined){
          newRoomId = key;
        }else if (key_index >= 0 && Object.keys(runningList[key].userList).length >= 8) {
          keyList.splice(key_index,1);
        }
      }
    }

    //choose room id
    if(keyList.length == 0){
      if(newRoomId == undefined){
        roomId = '@running'+keyLength;
      }else{
        roomId = newRoomId;
      }
    }else{
      roomId = keyList[Math.floor(Math.random()*keyList.length)];
    }

    if(runningList[roomId] == undefined){
      runningList[roomId] = {
        userList:{},
        adoptList:getAdoptList()
      };
      runningList[roomId].userList[socket.name] = {index:0};

      // var sum_speed = 0, sum_stamina = 0;
      // for(var i=0; i<runningList[roomId].adoptList.length; i++){
      //   runningList[roomId].adoptList[i].progress = 0;
      //   runningList[roomId].adoptList[i].boost = 0;
      //   runningList[roomId].adoptList[i].maxStamina = runningList[roomId].adoptList[i].stamina;
      //   runningList[roomId].adoptList[i].speedList = getSpeedList(runningList[roomId].adoptList[i].speed, 100);
        
      //   sum_speed += runningList[roomId].adoptList[i].speed;
      //   sum_stamina += runningList[roomId].adoptList[i].stamina;
      // }

      // var bet = [];
      // var stamina_rate;
      // for(var i=0; i<runningList[roomId].adoptList.length; i++){
      //   bet[i] = 1/(runningList[roomId].adoptList[i].speed/sum_speed)*5;
      //   if(bet[i] > 100){
      //     bet[i] = 100;
      //   }else if(bet[i] < 1){
      //     bet[i] = 1;
      //   }
      //   stamina_rate = 1/(runningList[roomId].adoptList[i].stamina/sum_stamina)*5;
      //   if(stamina_rate > 100){
      //     stamina_rate = 100;
      //   }else if(stamina_rate < 1){
      //     stamina_rate = 1;
      //   }
      //   bet[i] += stamina_rate;
      // }
      var sum_speed = 0, sum_stamina = 0, max = 0, min = 1000;
      for(var i=0; i<runningList[roomId].adoptList.length; i++){
        runningList[roomId].adoptList[i].progress = 0;
        runningList[roomId].adoptList[i].boost = 0;
        runningList[roomId].adoptList[i].maxStamina = runningList[roomId].adoptList[i].stamina;
        
        sum_speed += runningList[roomId].adoptList[i].speed;
        sum_stamina += runningList[roomId].adoptList[i].stamina;
        if(max < runningList[roomId].adoptList[i].speed){
          max = runningList[roomId].adoptList[i].speed;
        }
        if(min > runningList[roomId].adoptList[i].speed){
          min = runningList[roomId].adoptList[i].speed;
        }
      }
      runningList[roomId].max = max;
      runningList[roomId].min = min;
      console.log('max:'+max+'/min:'+min);

      var bet = [];
      var stamina_rate;
      for(var i=0; i<runningList[roomId].adoptList.length; i++){
        runningList[roomId].adoptList[i].speedList = getSpeedList(runningList[roomId].adoptList[i].speed, 100, roomId);
        bet[i] = 1/(runningList[roomId].adoptList[i].speed/sum_speed)*5;
        if(bet[i] > 100){
          bet[i] = 100;
        }else if(bet[i] < 1){
          bet[i] = 1;
        }
        stamina_rate = 1/(runningList[roomId].adoptList[i].stamina/sum_stamina)*5;
        if(stamina_rate > 100){
          stamina_rate = 100;
        }else if(stamina_rate < 1){
          stamina_rate = 1;
        }
        bet[i] += stamina_rate;
        bet[i] = Math.floor(bet[i]);
      }
      runningList[roomId].betData = bet;
      
      //set timer
      runningList[roomId].timer = setTimeout(betting_end, 30000, roomId);
      runningList[roomId].timer._now = Date.now();
      runningList[roomId].timer._turn = 'bet';

      decData['result'] = 'success';
      decData['seatNum'] = 0;
      decData['adoptData'] = runningList[roomId].adoptList;
      decData['betData'] = runningList[roomId].betData;
      decData['leftTime'] = 30;
      decData['room'] = roomId;

      socket.join(roomId);
      socket.room = roomId;
      socket.emit('running', AESCrypt.socketEncrypt(decData));
    }else{
      var toRoom = {};
      datasetup.getUserFromNick(socket.name, function(err, data){
        if(err){
          decData['result'] = 'fail';
          decData['error'] = err;
          socket.emit('running', AESCrypt.socketEncrypt(decData));
        }else{
          toRoom['userData'] = data[0];

          var nicknames = Object.keys(runningList[roomId].userList);
          datasetup.getUsersFromNick(nicknames, function(err, data){
            if(err){
              decData['result'] = 'fail';
              decData['error'] = err;
              socket.emit('running', AESCrypt.socketEncrypt(decData));
            }else{
              for(var i=0; i<data.length; i++){
                data[i].seatNum = runningList[roomId].userList[data[i].nickname].index;
              }

              var indexes = [];
              for(var i=0; i<nicknames.length; i++){
                indexes[runningList[roomId].userList[nicknames[i]].index] = true;
              }
              var index;
              for(var i=0; i<indexes.length; i++){
                if(indexes[i] == undefined){
                  index = i;
                  break;
                }
              }

              if(index == undefined){
                index = indexes.length;
              }
              
              toRoom['result'] = 'enter';
              toRoom['seatNum'] = index;
              io.to(roomId).emit('running', AESCrypt.socketEncrypt(toRoom));

              decData['result'] = 'enter';
              decData['seatNum'] = index;
              decData['userDatas'] = data;
              decData['adoptData'] = runningList[roomId].adoptList;
              decData['betData'] = runningList[roomId].betData;
              if(runningList[roomId].timer._turn == 'bet'){
                decData['leftTime'] = getTimeLeft(runningList[roomId].timer);
              }else{
                decData['second'] = (Date.now() - runningList[roomId].timer._now)/1000;
                decData['goal'] = runningList[roomId].goal;
              }
              decData['room'] = roomId;

              runningList[roomId].userList[socket.name] = {'index':index};
              socket.join(roomId);
              socket.room = roomId;
              socket.emit('running', AESCrypt.socketEncrypt(decData));
            }
          });
        }
      });
    }
  }else if(decData.type == 'bet'){
    if(runningList[socket.room] == undefined){
      var rec = {'req': 'running', 'reason': 'no room', 'nickname':socket.name, data:decData};
      datasetup.securityRecord(rec);
      socket.emit('wrong', AESCrypt.socketEncrypt(rec));

      socket.disconnect();
      return;
    }
    if(decData.adoptNum == undefined || decData.adoptNum < 0 || decData.adoptNum > 5){
      var rec = {'req': 'running', 'reason': 'Invalid adoptNum data', 'nickname':socket.name, data:decData};
      datasetup.securityRecord(rec);
      socket.emit('wrong', AESCrypt.socketEncrypt(rec));

      socket.disconnect();
      return;
    }
    
    if(runningList[socket.room].timer._turn == 'bet'){
      //bet
      if(runningList[socket.room].userList[socket.name] == undefined){
        var rec = {'req': 'running', 'reason': 'no user', 'nickname':socket.name, data:decData};
        datasetup.securityRecord(rec);
        socket.emit('wrong', AESCrypt.socketEncrypt(rec));

        socket.disconnect();
        return;
      }
      
      runningList[socket.room].userList[socket.name].adoptNum = decData.adoptNum;
      decData['result'] = 'success';
      socket.emit('running', AESCrypt.socketEncrypt(decData));
    }else{
      decData['result'] = 'fail';
      decData['error'] = 'diff_turn';
      socket.emit('running', AESCrypt.socketEncrypt(decData));
    }
  }else if(decData.type == 'cheer'){
    if(runningList[socket.room] == undefined){
      var rec = {'req': 'running', 'reason': 'no room', 'nickname':socket.name, data:decData};
      datasetup.securityRecord(rec);
      socket.emit('wrong', AESCrypt.socketEncrypt(rec));

      socket.disconnect();
      return;
    }

    if(runningList[socket.room].timer._turn == 'game'){
      //cheer
      if(runningList[socket.room].userList[socket.name] == undefined){
        var rec = {'req': 'running', 'reason': 'no user', 'nickname':socket.name, data:decData};
        datasetup.securityRecord(rec);
        socket.emit('wrong', AESCrypt.socketEncrypt(rec));

        socket.disconnect();
        return;
      }
      
      let adoptNum = runningList[socket.room].userList[socket.name].adoptNum;
      if(runningList[socket.room].userList[socket.name].timer == undefined
          && adoptNum != undefined && runningList[socket.room].adoptList[adoptNum]
          && runningList[socket.room].adoptList[adoptNum].stamina > 0){
        runningList[socket.room].adoptList[adoptNum].boost += 3;
        runningList[socket.room].userList[socket.name].timer = setTimeout(function(){
          delete runningList[socket.room].userList[socket.name].timer;
        }, 3000);

        decData['result'] = 'success';
        decData['second'] = runningList[socket.room].second;
        decData['adoptNum'] = adoptNum;
        decData['nickname'] = socket.name;
        io.to(socket.room).emit('running', AESCrypt.socketEncrypt(decData));
      }
    }
  }else if(decData.type == 'sync'){
    if(runningList[socket.room] == undefined){
      return;
    }

    if(runningList[socket.room].timer._turn == 'bet'){
      //leftTime
      decData['leftTime'] = getTimeLeft(runningList[socket.room].timer);
      
    }else if(runningList[socket.room].timer._turn == 'game'){
      //adoptData
      decData['second'] = (Date.now() - runningList[socket.room].timer._now)/1000;
      decData['adoptData'] = runningList[socket.room].adoptList;

    }
    decData['result'] = 'success';
    socket.emit('running', AESCrypt.socketEncrypt(decData));
  }else{
    var rec = {'req': 'running', 'reason': 'Invalid type data', 'nickname':socket.name, data:decData};
    datasetup.securityRecord(rec);
    socket.emit('wrong', AESCrypt.socketEncrypt(rec));

    socket.disconnect();
    return;
  }

  function betting_end(roomId){
    if(runningList[roomId] == undefined){
      return;
    }

    runningList[roomId].timer = setInterval(running_update, 1000, roomId);
    runningList[roomId].timer._now = Date.now();
    runningList[roomId].timer._turn = 'game';
    
    runningList[roomId].second = 0;
    runningList[roomId].rankList = [];
    var min_speed = 1000;
    for(var i=0; i<runningList[roomId].adoptList.length; i++){
      if(min_speed > runningList[roomId].adoptList[i].speed){
        min_speed = runningList[roomId].adoptList[i].speed;
      }
    }
    runningList[roomId].goal = (Math.floor(min_speed/1000)+1)*3080;

    var resData = {
      result: 'start',
      goal: runningList[roomId].goal
    };
    io.to(roomId).emit('running', AESCrypt.socketEncrypt(resData));
  }

  function running_update(roomId){
    if(runningList[roomId] == undefined){
      return;
    }
    // console.log(runningList[roomId].second);

    var amount;
    let adoptData = runningList[roomId].adoptList;
    for(var i=0; i<adoptData.length; i++){
      if(adoptData[i]){
        // console.log(adoptData[i].progress);
        amount = adoptData[i].speedList[runningList[roomId].second];
        if(adoptData[i].boost > 0){
          adoptData[i].boost -= 1;
          amount *= 1.2;
          if(adoptData[i].stamina > 0){
            if(adoptData[i].stamina < amount){
              amount = adoptData[i].stamina;
            }
            adoptData[i].stamina -= amount;
            adoptData[i].speedList[runningList[roomId].second] = amount;

          }else{
            adoptData[i].boost = 0;
          }
        }
        adoptData[i].progress += adoptData[i].speedList[runningList[roomId].second];
        
        if(adoptData[i].progress >= runningList[roomId].goal){
          var rankMem = adoptData[i];
          rankMem.betNum = i;
          rankMem.second = runningList[roomId].second;
          delete rankMem.boost;
          delete rankMem.speedList;
          runningList[roomId].rankList.push(rankMem);
          delete adoptData[i];
          continue;
        }
      }
    }
    
    if(runningList[roomId].rankList.length == 6){
      //rank 
      var rankData = runningList[roomId].rankList;
      var top = {second:rankData[0].second, progress:rankData[0].progress};
      for(var i=1; i<rankData.length; i++){
        if(top.second == rankData[i].second){
          if(top.progress < rankData[i].progress){
            top.progress = rankData[i].progress;
          }
        }
      }

      let nicknames = Object.keys(runningList[roomId].userList);
      for(var i=0; i<rankData.length; i++){
        if(top.second == rankData[i].second && top.progress == rankData[i].progress){
          for(var j=0; j<nicknames.length; j++){
            if(runningList[roomId].userList[nicknames[j]].adoptNum == rankData[i].betNum){
              datasetup.addUserCash(nicknames[j], runningList[roomId].betData[rankData[i].betNum]);
            }
          }

          if(rankData[i].nickname != undefined && rankData[i].adoptNum != undefined){
            datasetup.updateAdoptStatus(rankData[i].nickname, rankData[i].adoptNum, ["win_count", "game_count"]);
          }
        }else{
          if(rankData[i].nickname != undefined && rankData[i].adoptNum != undefined){
            datasetup.updateAdoptStatus(rankData[i].nickname, rankData[i].adoptNum, ["game_count"]);
          }
        }
      }

      //init
      for(var i=0; i<nicknames.length; i++){
        delete runningList[roomId].userList[nicknames[i]].adoptNum;
        if(runningList[roomId].userList[nicknames[i]].timer){
          clearTimeout(runningList[roomId].userList[nicknames[i]].timer);
          delete runningList[roomId].userList[nicknames[i]].timer;
        }
      }

      runningList[roomId].adoptList = getAdoptList();
      // var sum_speed = 0, sum_stamina = 0;
      // for(var i=0; i<runningList[roomId].adoptList.length; i++){
      //   runningList[roomId].adoptList[i].progress = 0;
      //   runningList[roomId].adoptList[i].boost = 0;
      //   runningList[roomId].adoptList[i].maxStamina = runningList[roomId].adoptList[i].stamina;
      //   runningList[roomId].adoptList[i].speedList = getSpeedList(runningList[roomId].adoptList[i].speed, 100);

      //   sum_speed += runningList[roomId].adoptList[i].speed;
      //   sum_stamina += runningList[roomId].adoptList[i].stamina;
      // }

      // var bet = [];
      // var stamina_rate;
      // for(var i=0; i<runningList[roomId].adoptList.length; i++){
      //   bet[i] = 1/(runningList[roomId].adoptList[i].speed/sum_speed)*5;
      //   if(bet[i] > 100){
      //     bet[i] = 100;
      //   }else if(bet[i] < 1){
      //     bet[i] = 1;
      //   }
      //   stamina_rate = 1/(runningList[roomId].adoptList[i].stamina/sum_stamina)*5;
      //   if(stamina_rate > 100){
      //     stamina_rate = 100;
      //   }else if(stamina_rate < 1){
      //     stamina_rate = 1;
      //   }
      //   bet[i] += stamina_rate;
      //   bet[i] = Math.floor(bet[i]);
      // }
      var sum_speed = 0, sum_stamina = 0, max = 0, min = 1000;
      for(var i=0; i<runningList[roomId].adoptList.length; i++){
        runningList[roomId].adoptList[i].progress = 0;
        runningList[roomId].adoptList[i].boost = 0;
        runningList[roomId].adoptList[i].maxStamina = runningList[roomId].adoptList[i].stamina;
        
        sum_speed += runningList[roomId].adoptList[i].speed;
        sum_stamina += runningList[roomId].adoptList[i].stamina;
        if(max < runningList[roomId].adoptList[i].speed){
          max = runningList[roomId].adoptList[i].speed;
        }
        if(min > runningList[roomId].adoptList[i].speed){
          min = runningList[roomId].adoptList[i].speed;
        }
      }
      runningList[roomId].max = max;
      runningList[roomId].min = min;
      console.log('max:'+max+'/min:'+min);

      var bet = [];
      var stamina_rate;
      for(var i=0; i<runningList[roomId].adoptList.length; i++){
        runningList[roomId].adoptList[i].speedList = getSpeedList(runningList[roomId].adoptList[i].speed, 100, roomId);
        bet[i] = 1/(runningList[roomId].adoptList[i].speed/sum_speed)*5;
        if(bet[i] > 100){
          bet[i] = 100;
        }else if(bet[i] < 1){
          bet[i] = 1;
        }
        stamina_rate = 1/(runningList[roomId].adoptList[i].stamina/sum_stamina)*5;
        if(stamina_rate > 100){
          stamina_rate = 100;
        }else if(stamina_rate < 1){
          stamina_rate = 1;
        }
        bet[i] += stamina_rate;
        bet[i] = Math.floor(bet[i]);
      }
      runningList[roomId].betData = bet;

      var resData = {
        result: "end",
        rankData: runningList[roomId].rankList,
        adoptData: runningList[roomId].adoptList,
        betData: runningList[roomId].betData
      };

      io.to(roomId).emit('running', AESCrypt.socketEncrypt(resData));
      clearInterval(runningList[roomId].timer);
      runningList[roomId].timer = setTimeout(betting_end, 30000, roomId);
      runningList[roomId].timer._now = Date.now();
      runningList[roomId].timer._turn = 'bet';

      return;
    }

    if(runningList[roomId].second%50 == 49){
      //send speedList
      var resData = {
        result:'speedList',
        speedData:[]
      };

      for(var i=0; i<adoptData.length; i++){
        if(adoptData[i]){
          var speedList = getSpeedList(adoptData[i].speed, 50, roomId);
          resData.speedData.push(speedList);
          adoptData[i].speedList = adoptData[i].speedList.concat(speedList);
        }
      }
      io.to(roomId).emit('running', AESCrypt.socketEncrypt(resData));
    }
    runningList[roomId].second += 1;
  }

  function getAdoptList(){
    var result;
    datasetup.getRandomAdoptCharacters(function(err, data){
      if(!err){
        if(data.length < 6){
          for(var i=0; i<data.length; i++){
            data[i].adoptData = JSON.parse(data[i].adoptData);
          }
          let randomCount = 6-data.length;
          for(var i=0; i<randomCount; i++){
            data.push(getRandomCharacter("character_"+i));
          }
        }else if(data.length > 6){
          //pick 6 character
          var adoptList = [];
          var adoptIndex;
          for(var i=0; i<6; i++){
            adoptIndex = Math.floor(Math.random()*data.length);
            data[adoptIndex].adoptData = JSON.parse(data[adoptIndex].adoptData);
            adoptList.push(data[adoptIndex]);
            data.splice(adoptIndex, 1);
          }
          data = adoptList;
        }else{
          for(var i=0; i<data.length; i++){
            data[i].adoptData = JSON.parse(data[i].adoptData);
          }
        }

        result = data;
      }
    });
    return result;
  }

  function getRandomCharacter(name){
    //skin, face can not be -1
    //skin, face, hair, top, bottom, shoes, hairac, stamina, speed
    let itemLength = datasetup.getItemLength()[datasetup.protocol.table_num.closet];
    var character = {
      adoptData:{
        nickname:name,
        skin:Math.floor(Math.random()*10),
        face:Math.floor(Math.random()*itemLength[datasetup.protocol.cloth_type.face]),
        hair:Math.floor(Math.random()*(itemLength[datasetup.protocol.cloth_type.hair]+1))-1,
        top:Math.floor(Math.random()*(itemLength[datasetup.protocol.cloth_type.top]+1))-1,
        bottom:Math.floor(Math.random()*(itemLength[datasetup.protocol.cloth_type.bottom]+1))-1,
        shoes:Math.floor(Math.random()*(itemLength[datasetup.protocol.cloth_type.shoes]+1))-1,
        hairac:Math.floor(Math.random()*(itemLength[datasetup.protocol.cloth_type.hairac]+1))-1
      },
      stamina:Math.floor(Math.random()*10000),
      speed:Math.floor(Math.random()*1000)
    };

    return character;
  }

  function getSpeedList(speed, count, roomId){
    let max = runningList[roomId].max;
    let min = runningList[roomId].min;
    var margin = (max-min)*0.1;
    var min_speed = speed*0.15;
    var max_speed;
    if(margin == 0){
      max_speed = min_speed+speed;
    }else{
      max_speed = min_speed+(max-speed)*(max-min-2*margin)/(max-min)+3*margin;
    }
    console.log('speed:'+speed+'/min_speed:'+min_speed+'/max_speed:'+max_speed);
    var speedList = [];
    for(var i=0; i<count; i++){
      speedList.push(Math.random()*(max_speed-min_speed)+min_speed);
    }
    return speedList;
  }
  // function getSpeedList(speed, count){
  //   var min_speed = speed*0.15;
  //   var max_speed = min_speed+100+(10-speed*0.01)*10;
  //   var speedList = [];
  //   for(var i=0; i<count; i++){
  //     speedList.push(Math.random()*(max_speed-min_speed)+min_speed);
  //   }
  //   return speedList;
  // }

});

function replaceAt(string, index, letter){
  return string.substring(0, index)+letter+string.substring(index+1);
}
});

server.listen(port);
server.on('error', onError);
server.on('listening', onListening);

/**
* Normalize a port into a number, string, or false.
*/

function normalizePort(val) {
var port = parseInt(val, 10);

if (isNaN(port)) {
  // named pipe
  return val;
}

if (port >= 0) {
  // port number
  return port;
}

return false;
}

/**
* Event listener for HTTP server "error" event.
*/

function onError(error) {
if (error.syscall !== 'listen') {
  throw error;
}

var bind = typeof port === 'string'
  ? 'Pipe ' + port
  : 'Port ' + port;

// handle specific listen errors with friendly messages
switch (error.code) {
  case 'EACCES':
    console.error(bind + ' requires elevated privileges');
    process.exit(1);
    break;
  case 'EADDRINUSE':
    console.error(bind + ' is already in use');
    process.exit(1);
    break;
  default:
    throw error;
}
}

/**
* Event listener for HTTP server "listening" event.
*/

function onListening() {
var addr = server.address();
var bind = typeof addr === 'string'
  ? 'pipe ' + addr
  : 'port ' + addr.port;
debug('Listening on ' + bind);
}